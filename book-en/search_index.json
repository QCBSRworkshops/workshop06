[["index.html", "Workshop 6: Generalized linear models QCBS R Workshop Series Preface 0.1 Code of conduct 0.2 Contributors 0.3 Contributing", " Workshop 6: Generalized linear models QCBS R Workshop Series Developed and maintained by the contributors of the QCBS R Workshop Series1 2021-03-16 17:09:08 Preface The QCBS R Workshop Series is a series of 10 workshops that walks participants through the steps required to use R for a wide array of statistical analyses relevant to research in biology and ecology. These open-access workshops were created by members of the QCBS both for members of the QCBS and the larger community. The content of this workshop has been peer-reviewed by various QCBS members. If you would like to suggest modifications, please contact the current series coordinators, listed on the main Github page. 0.1 Code of conduct The QCBS R Workshop Series and the QCBS R Symposium are venues dedicated to providing a welcoming and supportive environment for all people, regardless of background or identity. Participants, presenters and organizers of the workshop series and other related activities accept this Code of Conduct when being present at any workshop-related activities. We do not tolerate behaviour that is disrespectful or that excludes, intimidates, or causes discomfort to others. We do not tolerate discrimination or harassment based on characteristics that include, but are not limited to, gender identity and expression, sexual orientation, disability, physical appearance, body size, citizenship, nationality, ethnic or social origin, pregnancy, familial status, genetic information, religion or belief (or lack thereof), membership of a national minority, property, age, education, socio-economic status, technical choices, and experience level. It applies to all spaces managed by or affiliated with the workshop, including, but not limited to, workshops, email lists, and online forums such as GitHub, Slack and Twitter. 0.1.1 Expected behaviour All participants are expected to show respect and courtesy to others. All interactions should be professional regardless of platform: either online or in-person. In order to foster a positive and professional learning environment we encourage the following kinds of behaviours in all workshop events and platforms: Use welcoming and inclusive language; Be respectful of different viewpoints and experiences; Gracefully accept constructive criticism; Focus on what is best for the community; Show courtesy and respect towards other community members. 0.1.2 Unacceptable behaviour Examples of unacceptable behaviour by participants at any workshop event/platform include: written or verbal comments which have the effect of excluding people on the - basis of membership of any specific group; causing someone to fear for their safety, such as through stalking or intimidation; violent threats or language directed against another person; the display of sexual or violent images; unwelcome sexual attention; nonconsensual or unwelcome physical contact; insults or put-downs; sexist, racist, homophobic, transphobic, ableist, or exclusionary jokes; incitement to violence, suicide, or self-harm; continuing to initiate interaction (including photography or recording) with - someone after being asked to stop; publication of private communication without consent. 0.2 Contributors Originally developed by: Cédric Frenette Dussault, Vincent Fugère, Thomas Lamy, Zofia Taranu Contributed with changes to the presentation: Contributed with changes to the written material: Contributed by reporting issues and suggesting modifications: 0.3 Contributing Under construction. The QCBS R Workshop Series is part of the Québec Centre for Biodiversity Science, and is maintained by the series coordinators and graduent student, postdoctoral, and research professional members. The contributors for this workshop can be accessed here.↩︎ "],["learning-objectives.html", "Chapter 1 Learning objectives", " Chapter 1 Learning objectives A significant limitation of general linear models is that they cannot accommodate response variables that do not have a normal error distribution - a situation that is very common when analyzing biological data. In this workshop, you will learn how to use generalized linear models, which are powerful tools to overcome some of the distributional assumptions of linear models. Especifically, we will: Distinguish generalized linear models from general linear models (including many of their equations!). Identify situations for when the use of generalized linear models is appropriate. Test assumptions for generalized linear models. Implement and execute generalized linear models in binary, proportion and count data. Validate, interprete and visualise results of generalized linear models. "],["preparing-for-the-workshop.html", "Chapter 2 Preparing for the workshop", " Chapter 2 Preparing for the workshop To prepare for this workshop, you must download and install the earliest RStudio and R versions. You must also download the data we will use during this workshop: Mites Faramea This workshop requires the following R packages: ggplot2 MASS vcdExtra bbmle DescTools To install them from CRAN, run: install.packages(c(&quot;ggplot2&quot;, &#39;MASS&#39;, &#39;vcdExtra&#39;, &#39;bbmle&#39;, &#39;DescTools&#39;) ) To load these packages, run: library(ggplot2) library(MASS) library(vcdExtra) ## Loading required package: vcd ## Loading required package: grid ## Loading required package: gnm library(bbmle) ## Loading required package: stats4 library(DescTools) This workshop will build up your knowledge on models along side with some of their important equations. Do not run to the mountains! This will be achieved progressively and you will feel proud of yourself after! "],["reviewing-linear-models.html", "Chapter 3 Reviewing linear models 3.1 General linear models", " Chapter 3 Reviewing linear models Much of our research focuses on investigating how patterns we observe can be explained by predictive variables. We are often looking for a function \\(f\\) that can explain a response variable ( \\(Y\\) ) in terms of one ( \\(X_1\\) ) or many other predictors ( \\(X_2\\), \\(X_3\\), \\(...\\) , \\(X_n\\) ): \\[Y = f(X_1)\\] The combination of predictive variables we have sampled will never fully explain \\(Y\\). Because of this, there is always unpredictable disturbance in our models, i.e. the error \\(\\epsilon\\). As such, the error is an irrevocable part of our function: \\[Y = f(X_1, \\epsilon)\\] In Workshop 4, we have learned how to use general linear models as \\(f(\\cdot)\\) to describe the relationship between variables. They were: the \\(t\\)-test, the analysis of variance (or, ANOVA), the linear regression (both simple, with one predictor, and multiple, with more than one predictor), and the analysis of covariance (ANCOVA). 3.1 General linear models 3.1.1 Definition The general form of our function \\(Y = f(X_1)\\) as a linear function can be represented by: \\[Y = \\beta_0 + \\beta_1X_i + \\varepsilon\\] where: \\(Y_i\\) is thepredicted value of a response variable \\(\\beta_0\\) is the unknown coefficient intercept \\(\\beta_1\\) is the unknown coefficient slope \\(X_i\\) is the value for the explanatory variable \\(\\varepsilon_i\\) is the model residual drawn from a normal distribution with a varying mean but a constant variance. 3.1.2 Assumptions Linear models only produce unbiased estimators (i.e. are only reliable) if they follow certain assumptions. Most importantly: 1. The population can be described by a linear relationship: \\[Y = \\beta_0 + \\beta_1X_i + \\varepsilon\\] 2. The error term \\(\\varepsilon\\) has the same variance given any value of the explanatory variable (i.e. homoskedasticity), and the error terms are not correlated across observations (i.e. no autocorrelation): \\[\\mathbb{V}{\\rm ar} (\\epsilon_i | \\mathbf{X} ) = \\sigma^2_\\epsilon,\\ \\forall i = 1,..,N\\] and, \\[\\mathbb{C}{\\rm ov} (\\epsilon_i, \\epsilon_j) = 0,\\ i \\neq j\\] 3. And, the residuals are normal: \\[\\boldsymbol{\\varepsilon} | \\mathbf{X} \\sim \\mathcal{N} \\left( \\mathbf{0}, \\sigma^2_\\epsilon \\mathbf{I} \\right)\\] "],["an-example-with-general-linear-models.html", "Chapter 4 An example with general linear models 4.1 Recalling linear models: assumptions", " Chapter 4 An example with general linear models Let us use our prior knowledge on general linear models to explore the relationship between variables within the Oribatid mite dataset. Let us begin by loading this dataset into R: # Use setwd() to set your working directory mites &lt;- read.csv(&#39;data/mites.csv&#39;, stringsAsFactors = TRUE) The dataset that you just loaded is a subset from the classic ‘Oribatid mite dataset’, which has been used in numerous texts (e.g. Borcard, Gillet &amp; Legendre, Numerical Ecology with R), and which is available in the vegan library. The Oribatid mite dataset has 70 observations with moss and mite samples collected Station de Biologie des Laurentides from the Université de Montréal, within the municipality of Saint-Hippolyte, Québec (Canada). Each sample includes 5 variables of environmental measurements and abundance for Galumna sp. for each site. We can peek into the structure and the first six rows of the dataset using the head() and str() functions: head(mites) ## Galumna pa totalabund prop SubsDens WatrCont Substrate Shrub Topo ## 1 8 1 140 0.057142857 39.18 350.15 Sphagn1 Few Hummock ## 2 3 1 268 0.011194030 54.99 434.81 Litter Few Hummock ## 3 1 1 186 0.005376344 46.07 371.72 Interface Few Hummock ## 4 1 1 286 0.003496503 48.19 360.50 Sphagn1 Few Hummock ## 5 2 1 199 0.010050251 23.55 204.13 Sphagn1 Few Hummock ## 6 1 1 209 0.004784689 57.32 311.55 Sphagn1 Few Hummock str(mites) ## &#39;data.frame&#39;: 70 obs. of 9 variables: ## $ Galumna : int 8 3 1 1 2 1 1 1 2 5 ... ## $ pa : int 1 1 1 1 1 1 1 1 1 1 ... ## $ totalabund: int 140 268 186 286 199 209 162 126 123 166 ... ## $ prop : num 0.05714 0.01119 0.00538 0.0035 0.01005 ... ## $ SubsDens : num 39.2 55 46.1 48.2 23.6 ... ## $ WatrCont : num 350 435 372 360 204 ... ## $ Substrate : Factor w/ 7 levels &quot;Barepeat&quot;,&quot;Interface&quot;,..: 4 3 2 4 4 4 4 2 3 4 ... ## $ Shrub : Factor w/ 3 levels &quot;Few&quot;,&quot;Many&quot;,&quot;None&quot;: 1 1 1 1 1 1 1 2 2 2 ... ## $ Topo : Factor w/ 2 levels &quot;Blanket&quot;,&quot;Hummock&quot;: 2 2 2 2 2 2 2 1 1 2 ... Our first glance into the dataset already allows us to separate potential response variables from potential predictors: Response variables: Occurrence: pa Abundance: Galumna Relative Frequency or Proportion: prop Predictive variables: Substract Density: SubsDens Water Content: WatrCont Substrate: Substrate Shrubs Nearby: Shrub Topography: Topo We can also already ellaborate an initial question: Could the abundance, occurrence or proportion of Galumna sp. be predicted by environmental features? To answer this question, we can think of a variety of functions: \\(\\text{Abundance} = f(\\text{Water content}, \\epsilon)\\) \\(\\text{Proportion} = f(\\text{Water content}, \\epsilon)\\) \\(\\text{Occurrence} = f(\\text{Substrate}, \\epsilon)\\) \\(\\text{Abundance} = f(\\text{Topography}, \\epsilon)\\) \\(\\text{Occurrence} = f(\\text{Shrubs Nearby}, \\epsilon)\\) \\(\\text{Relative Frequency} = f(\\text{Topography}, \\epsilon)\\) \\(\\text{Occurrence} = f(\\text{Substract Density}, \\epsilon)\\) \\(\\text{Abundance} = f(\\text{Substrate}, \\epsilon)\\) ] Let us attempt to be more specific and ask wether Galumna’s community values (abundance, occurrence and relative frequency) vary as a function of water content. We can begin by representing all three response variables against the predictor: par(mfrow = c(1, 3), cex = 1.4) plot(Galumna ~ WatrCont, data = mites, xlab = &#39;Water content&#39;, ylab = &#39;Abundance&#39;) boxplot(WatrCont ~ pa, data = mites, xlab=&#39;Presence/Absence&#39;, ylab = &#39;Water content&#39;) plot(prop ~ WatrCont, data = mites, xlab = &#39;Water content&#39;, ylab = &#39;Proportion&#39;) Indeed, Galumna seems to vary negatively as a function of WatrCont, i.e. Galumna sp. seems to prefer dryer sites. We can go step further and fit general linear models to test whether Galumna, pa, and/or prop vary as a function of WatrCont lm.abund &lt;- lm(Galumna ~ WatrCont, data = mites) ## summary(lm.abund) lm.pa &lt;- lm(pa ~ WatrCont, data = mites) ## summary(lm.pa) lm.prop &lt;- lm(prop ~ WatrCont, data = mites) Then, we can check the model output to verify whether these relationships are statistically significant: summary(lm.abund) ## ## Call: ## lm(formula = Galumna ~ WatrCont, data = mites) ## ## Residuals: ## Min 1Q Median 3Q Max ## -1.7210 -0.8236 -0.3270 0.3910 6.6772 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 3.439349 0.555825 6.188 3.98e-08 *** ## WatrCont -0.006045 0.001280 -4.723 1.21e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 1.514 on 68 degrees of freedom ## Multiple R-squared: 0.247, Adjusted R-squared: 0.2359 ## F-statistic: 22.31 on 1 and 68 DF, p-value: 1.206e-05 summary(lm.pa) ## ## Call: ## lm(formula = pa ~ WatrCont, data = mites) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.61320 -0.30889 -0.05498 0.30247 0.80073 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.1892142 0.1431306 8.309 6.03e-12 *** ## WatrCont -0.0020263 0.0003296 -6.148 4.68e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.3897 on 68 degrees of freedom ## Multiple R-squared: 0.3573, Adjusted R-squared: 0.3478 ## F-statistic: 37.8 on 1 and 68 DF, p-value: 4.677e-08 summary(lm.prop) ## ## Call: ## lm(formula = prop ~ WatrCont, data = mites) ## ## Residuals: ## Min 1Q Median 3Q Max ## -0.010208 -0.004927 -0.002056 0.003240 0.049252 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 2.020e-02 3.294e-03 6.133 4.98e-08 *** ## WatrCont -3.516e-05 7.586e-06 -4.635 1.67e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## Residual standard error: 0.008971 on 68 degrees of freedom ## Multiple R-squared: 0.2401, Adjusted R-squared: 0.2289 ## F-statistic: 21.49 on 1 and 68 DF, p-value: 1.665e-05 # Extracting the Pr(&gt;|t|) summary(lm.abund)$coefficients[, 4] ## (Intercept) WatrCont ## 3.981563e-08 1.206117e-05 summary(lm.pa)$coefficients[, 4] ## (Intercept) WatrCont ## 6.030252e-12 4.676755e-08 summary(lm.prop)$coefficients[, 4] ## (Intercept) WatrCont ## 4.977432e-08 1.665437e-05 Yes, there is a strong and significant relationship for all 3 response variables! Wait a minute… We are forgetting something important here! What about the assumptions of linear models? 4.1 Recalling linear models: assumptions Let’s validate these models to make sure that we respect assumptions of linear models, starting with the abundance model. We can see a strong and significant relationship for all three models, concerning each one of the three response variables! Nevertheless, we cannot forget the most important step: verifying if the assumptions for these general linear models have not been violated. Let us begin by validating these models to make sure that we respect assumptions of linear models, starting with the abundance model. plot(Galumna ~ WatrCont, data = mites) abline(lm.abund) The model does not fit well. It predicts negative abundance values when WatrCont exceeds 600, which does not make any sense. Also, the model does poorly at predicting high abundance values at low values of WatrCont. We can also check the model diagnostic plots: plot(lm.abund) Diagnostic plots show that the data/model violate assumptions of homogeneity of variance (the graph on the left shows that residuals are larger at higher fitted values) and normality (the graph on the right indicates that residuals are not distributed as expected from a normal distribution, i.e. many points are far from predicted values given by the dotted line). Therefore, we need to reject this model, and can’t use it to conclude that Galumna abundance varies as a function of water content. Looking at diagnostic plots for the presence-absence model and the proportion model also indicate that these models are also inappropriate: # Plot the proportion model plot(prop ~ WatrCont, data = mites) abline(lm.prop) # Diagnostic plots plot(lm.prop) # Plot the presence/absence model plot(pa ~ WatrCont, data = mites) abline(lm.pa) # Diagnostic plots plot(lm.pa) Let’s take a step back here and review the assumptions of linear models, and where they come from. Remember our simple linear model? \\[Y_i = \\beta_0 + \\beta_1X_i + \\varepsilon\\] where: \\(Y_i\\) is the predicted value of a response variable \\(\\beta_0\\) is the unknown coefficient intercept _1$ is the unknown coefficient slope \\(X_i\\) is the value of the explanatory variable \\(\\varepsilon_i\\) is the model residual drawn from a normal distribution with a varying mean but a constant variance. This last point about \\(\\varepsilon_i\\) is important. This is where assumptions of normality and homoscedasticity originate. It means that the residuals (the distance between each observation and the regression line) can be predicted by drawing random values from a normal distribution. Recall that all normal distributions have two parameters, \\(\\mu\\) (the mean of the distribution) and \\(\\sigma^2\\) (the variance of the distribution). In a linear model, \\(\\mu\\) changes based on values of \\(X\\) (the predictor variable), but \\(\\sigma^2\\) has the same value for all values of \\(Y\\). Our simple linear can also be written as this: \\[Y_i \\sim N(\\mu = \\beta_0 + \\beta_1 X_i +\\varepsilon, \\sigma^2)\\] with \\(N(\\cdot)\\) meaning that \\(Y_i\\) is drawn from a normal distribution with parameters \\(\\mu\\) (mean; which depends on \\(x_i\\)) and \\(\\sigma\\) (variance; which has the same value for all \\(Y_i\\)s). Let’s take a look at what happens to the distribution when we vary the parameters \\(\\mu\\) and \\(\\sigma\\). Varying \\(\\mu\\) while \\(\\sigma = 5\\) shifts the mean of the distribution. If we keep \\(\\mu = 25\\), varying \\(\\sigma\\) changes the shape of the distribution, where smaller \\(\\sigma\\) (low variance) means there is higher probability around the mean, while larger \\(\\sigma\\) spreads out the probabilities across the full range of values. 4.1.1 Model prediction When the assumptions of the linear model are not met, model prediction becomes problematic. Let’s work through an example to demonstrate some of the problems that arise from a poorly fitted model. Remember that when we predict, we aim at estimating the unknown coefficients \\(\\beta_0\\) and \\(\\beta_1\\) so that a line effectively predicting every value of \\(Y\\) as a function of \\(X\\) can be drawn! \\[Y_i \\sim N(\\mu = \\beta_0 + \\beta_1 X_i +\\varepsilon, \\sigma^2)\\] Let’s predict Galumna abundance at a water content = 300 using the linear model we fit above. What are the parameters of the normal distribution used to model \\(Y\\) when water content is \\(300\\)? Let’s begin by obtaining the parameters \\(\\mu\\) and \\(\\sigma^2\\) for a normal distribution corresponding to our equation. To obtain the coefficients from our models, we can use the function coef(): coef(lm.abund) ## (Intercept) WatrCont ## 3.439348672 -0.006044788 These coefficients would allow us to predict Galumna abundance if there was no error. However, we know that error is an irrevocable part of our model. To get our predicted values, we therefore also need to add . This is where we use the normal distribution! For \\(X\\) = 300, our model predicts that should follow a normal distribution with mean = 1.63. We can extract the variance (\\(\\sigma^2\\)) from our model summary: summary(lm.abund)$sigma ## [1] 1.513531 We can plug these values into the equation we just discussed above: \\[Y_i \\sim N(\\mu = \\beta_0 + \\beta_1 X_i +\\varepsilon, \\sigma^2)\\] \\(\\mu = 3.44 + (-0.006 \\times 300) = 1.63\\) \\(\\sigma^2 = 1.51\\) This tells us that randomly drawn \\(Y\\) values when water content is \\(300\\) should be on average \\(1.63\\) and have a variance of \\(1.51\\). In other words, at \\(x = 300\\), residuals should follow a normal distribution with \\(\\mu = 1.63\\) and \\(\\sigma^2 = 1.51\\). At \\(x = 400\\), we get \\(\\mu = 1.02\\) and \\(\\sigma^2 = 1.51\\), etc. At a water content of 400, residuals should follow a normal distribution with parameters \\(\\mu = 3.44 + (-0.006 x 400) = 1.02\\) and \\(\\sigma^2 = 1.51\\), etc. Each \\(Y\\) value is modeled using a normal distribution with a mean that depends on \\(X_i\\), but with a variance that is constant \\(\\sigma^2 = 1.51\\) across all \\(X_i\\) values. Graphically, this looks like this: The four normal distributions on this graph represent the probability of observing a given Galumna abundance for 4 different water content values. The mean of the normal distribution varies as a function of water content (hence \\(\\mu\\) decreases with water content), but \\(\\sigma^2\\) is always 1.51 (i.e. the variance is homogeneous across all values of \\(X\\)). This model is inappropriate for at least two reasons: 1. Values are on average further from the regression line at low water content values. That is, there is more residual variance around the predicted values for low values of \\(X\\), such that \\(\\varepsilon\\) varies as a function of \\(X\\), thus violating the assumption of homoscedasticity. It makes no sense to use a constant value of \\(\\sigma^2\\): the normal distributions used to predict \\(Y\\) at low values of \\(X\\) should ideally be wider (have a larger \\(\\sigma^2\\)) than normal distributions used to predict \\(Y\\) at large \\(X\\) values, but linear models do not permit this. 2. The residuals do not follow a normal distribution with constant variance across all values of \\(X\\). The variance of the residuals’ distribution changes as a function of \\(X\\) (see the spread of the data points around the trendline!). 3. The predicted values do not make sense, given the observations. Our response variable is abundance, which can only take integer values. Yet, at water content = 300, the abundance value that our model predicts to be the most probable is 1.63! We know that the probability of observing 1.63 individuals at water content = 300 is actually zero, as is the probability of observing any fraction (non-integers). Our predicted values should be modeled using a distribution that only predicts integers, rather than a continuous distribution like the normal distribution. This is a very common problem, as biological data often follows one of the myriad other statistical distributions besides the normal distribution. 4.1.2 So, what do we do now? Transform our data? Very often, data will not “behave” and will violate the assumptions we have seen, showing evidence for non-normality and/or heteroskedasticity. We have been told to transform our data using logarithmic, square-root, and cosine transformations to get around these problems. Unfortunately, transformations not always work and come with a few drawbacks: 1. They change the response variable (!), making interpretation challenging; 2. They may not simulateneously improve linearity and homogeneity of variance; 3. The boundaries of the sample space change. For instance, our simple linear model: \\[Y_i = \\beta_0 + \\beta_1X_i + \\varepsilon\\] looks like this under a log-transform: \\[E(\\log{Y_i}) = \\beta_0 + \\beta_1X_i \\] It is, of course, much less intuitive to interpret that for every \\(300\\) units increase in water content, Galumna abundance takes the form of \\(\\log(1.63)\\)… Thankfully, the normal distribution is not our only option! "],["the-distributions-of-biological-data.html", "Chapter 5 The distributions of biological data", " Chapter 5 The distributions of biological data Statisticians have described a multitude of distributions that correspond to different types of data. A distribution provides the probability of observing each possible outcome of an experiment or survey (for example, abundance = 8 Galumna is one such \"outcome\" of a survey). \"Discrete\" distributions have a range that only includes integers, while \"continuous\" distributions have a range that also includes fractions (the normal distribution is an example of a continuous distribution). All distributions have parameters that dictate the shape of the distribution (for example μ and σ2 for the normal distribution). For a good overview of statistical distributions, we recommend that you refer to chapter 4 in Ben Bolker’s Ecological Models and Data in R. Here we just discuss briefly a few distributions that are useful for ecologists and generalized linear modeling. We have already seen that our response variable \"Galumna abundance\" can only take integer values. Abundance, therefore, follows a discrete distribution, with no fractions in its range. A useful distribution to model abundance data is the \"Poisson\" distribution, named after Siméon Denis Poisson. The Poisson distribution is a discrete distribution with a single parameter, λ (lambda), which defines both the mean and the variance of the distribution (i.e. the mean and the variance of a Poisson distribution are equal). Here are 3 examples of Poisson distributions with different values of λ, corresponding in this case to the mean number of Galumna observed in a fictive set of samples: Note that at low λ values (when the mean is close to zero), the distribution is skewed to the right, while at large λ values (large mean) the distribution is symmetrical. The variance increases with the mean, predicted values are always integers, and the range of a Poisson distribution is always strictly positive; all of these properties are useful to model count data, for example abundance of a given taxon, number of seeds in a plot, etc. Our variable mites$Galumna seems to follow a Poisson distribution with a low value of λ (indeed, if we calculate the mean abundance of Galumna across all samples using the function mean(), we find that it is close to zero): hist(mites$Galumna) mean(mites$Galumna) ## [1] 0.9571429 Our variable mites$pa (presence-absence) takes yet another form. It consists of only zeros and ones, such that a Poisson distribution would not be appropriate to model this variable. hist(mites$pa) We need a distribution with a range that only includes two possible outcomes: zero or one. The \"Bernoulli\" distribution is such a distribution. It is often the first distribution that students of statistics are introduced to, for example when discussing the probability of obtaining the outcome \"heads\" when flipping a coin. The Bernoulli distribution has only one parameter, p, the probability of success (i.e. the probability of obtaining heads on a coin flip). If we consider that each of our samples is equivalent to a coin toss, then we can use the Bernouilli distribution to calculate the probability of obtaining the outcome \"Galumna present\" (1) vs. \"Galumna absent\" (0). Here are some examples of Bernoulli distributions with various probabilities of presence (p): We can calculate the number of sites where Galumna is present out of the total number of sites to get an idea of what p might be in our case: sum(mites$pa) / nrow(mites) ## [1] 0.3571429 p for the variable mites$pa is more or less 0.36, such that roughly twice as many sites have the outcome \"Galumna absent\" (0) than the outcome \"Galumna present\" (1). When there are multiple trials/coin tosses, the Bernouilli distribution expands into the binomial distribution, which has the additional parameter n, corresponding to the number of trials. The binomial distribution predicts the probability of observing a given proportion of successes, p, out of a known total number of trials, n. \"Successes\" can be anything from taxon occurrence, number of surviving individuals out of a sample, etc. Imagine that instead of only working in the Laurentians, we took 50 mite samples at each of 30 regions across Canada. In each sample from each region, we determine if Galumna is present or absent. We could model this data using a binomial distribution with n = 50 samples (i.e. \"trials\" or coin flips where Galumna can be either present or absent) and p = the average proportion of samples in which Galumna is present. We would have 30 data points, corresponding to the 30 regions. Here are some examples of binomial distributions with n = 50 and 3 different values of p: Notice that the binomial distribution is right-skewed at low p values but left-skewed at high p values. This is the main difference with the Poisson distribution: the binomial distribution has an upper limit to its range, corresponding to the number of trials, n. Consequently, the binomial distribution is often used to model data where the number of successes are integers and where the number of trials is known. For example, we could use the binomial distribution to model our proportion data, where each individual mite in a sample could be considered a trial, and if the mite is a Galumna individual then the trial is a success. In this case, the number of trials n varies among our 70 samples based on the total number of individuals in the sample, while p, the probability of success, is given by the proportion of Galumna in each sample. Why are we discussing all of these distributions? Because all of them can be used to replace the normal distribution when calculating predicted values in a linear model. For example, we could use the Poisson distribution and model our abundance data with the following equation: yi ~ Poisson(λ = β0 + β1xi) Notice that λ varies as a function of x (water content), meaning that the residual variance will also vary with x. This means that we just relaxed the homogeneity of variance assumption! Also, predicted values will now be integers instead of fractions because they will all be drawn from Poisson distributions with different λ values. The model will never predict negative values because Poisson distributions have strictly positive ranges. By simply switching the distribution of error terms (εi) from normal to Poisson, we solved most of the problems of our abundance linear model. This new model is almost a Poisson generalized linear model, which basically looks like this: Notice that probabilities of observations/predicted values (in orange, as for the lm model above) are now integers, and that both the variance and the mean of the distribution decline as λ decreases with increasing water content. Why is the fitted line of predicted values curved? Why is this called a \"generalized\" linear model? Keep reading and you’ll find out! "],["binomial-glms-bernouilli.html", "Chapter 6 Binomial GLMs (Bernouilli) 6.1 The link function 6.2 Interpreting the output of a logistic regression 6.3 Predictive power and goodness-of-fit 6.4 Plotting results", " Chapter 6 Binomial GLMs (Bernouilli) A common response variable in ecological datasets is the binary variable: we observe a phenomenon \\(Y\\) or its “absence”. For example, species presence/absence is frequently recorded in ecological monitoring studies. We usually wish to determine whether a species’ presence is affected by some environmental variables. Other examples include the presence/absence of a disease within a wild population, the success/failure to record a specific behaviour, and the survival/death of organisms. Usually, we are interested in questions such as: how do species occurrences vary in function of the environment? \\[Occurrences = f(Environment)\\] A regression that has a binary response variable is one of many generalized linear models and is called a logistic regression or a logit model. In R, presence (or success, survival…) is usually coded as 1 and absence (or failure, death…) as 0. A logistic regression (or any other generalized linear model) is performed with the glm() function. This function is different from the basic lm() as it allows one to specify a statistical distribution other than the normal distribution. We’ve already seen that binary variables are not normally distributed (i.e. we see a peak at 0 and a peak at 1 and nothing in between). Like we have seen in the previous section, the Bernoulli distribution is well suited for binary response variables. The mean of this distribution is the probability \\(p\\) of observing an outcome and the variance is \\(p/(1 - p)\\). The \\((1 - p)\\) term represents the probability of not observing an outcome. In R, we specify the distribution with the family argument. For the logistic regression, we code it as: family=\"binomial\". Remember that the Bernoulli distribution is a special case of the binomial distribution when the number of repetitions is 1: R will “understand” that it is a Bernoulli distribution. When predicting the probability of observing some phenomenon \\(Y\\), which is a binary variable, the expected values should be bound between 0 and 1: that’s the range of a probability value! If we use a basic linear model to relate a binary response variable to various explanatory variables, we might obtain fitted values outside of the \\([0,1]\\) range, which is nonsensical. The following example will help you understand why a basic linear model is inappropriate here. The next subsection will show you how to avoid this problem with a link function. Briefly, a link function is used to linearize the relationship between predicted values of the response variable and the linear predictor (see next subsection). model.lm &lt;- lm(pa ~ WatrCont + Topo, data = mites) # Let&#39;s get the expected values for the response variable. fitted(model.lm) ## 1 2 3 4 5 6 ## 0.66647889 0.53692818 0.63347146 0.65064083 0.88992555 0.72554642 ## 7 8 9 10 11 12 ## 0.62243838 0.44918156 0.38197312 0.86452345 0.65216882 0.58115232 ## 13 14 15 16 17 18 ## 0.82937368 0.49091140 0.32085505 0.70975427 0.74788803 0.77927339 ## 19 20 21 22 23 24 ## 0.27006616 0.97936848 0.92066821 0.91783725 0.59213949 0.75609015 ## 25 26 27 28 29 30 ## 0.40830867 0.45469271 0.97998058 0.65973050 0.70784146 0.24024164 ## 31 32 33 34 35 36 ## 0.44598561 0.42241754 0.26475620 0.29565189 0.41782680 0.21776232 ## 37 38 39 40 41 42 ## 0.25508504 0.04877715 -0.20118869 0.24807651 0.14103573 0.26617933 ## 43 44 45 46 47 48 ## -0.03165263 -0.22623884 0.03336756 0.16659086 0.36168204 0.08179987 ## 49 50 51 52 53 54 ## 0.30060989 0.19286520 0.14544285 -0.04279283 0.22290395 0.04560953 ## 55 56 57 58 59 60 ## 0.17240580 0.04198285 -0.08121733 0.31664687 -0.14695674 0.14463181 ## 61 62 63 64 65 66 ## -0.10106464 -0.11390341 0.11942865 0.19182463 0.46870977 0.06957320 ## 67 68 69 70 ## -0.40803217 -0.04559318 0.46895461 0.41060630 # Some values are lower than 0, which does not make sense for a # logistic regression. Let’s try the same model with a binomial # distribution instead. model.glm &lt;- glm(pa ~ WatrCont + Topo, data = mites, family = &quot;binomial&quot;) # Notice the &quot;family&quot; argument to specify the distribution. fitted(model.glm) ## 1 2 3 4 5 6 ## 0.7346594257 0.4206031345 0.6631394056 0.7015590344 0.9653549812 0.8359993456 ## 7 8 9 10 11 12 ## 0.6372174958 0.5611742138 0.3897035615 0.9554194818 0.9124133201 0.5341181089 ## 13 14 15 16 17 18 ## 0.9371232991 0.6630994614 0.2534848511 0.8123833970 0.8652527310 0.8987976705 ## 19 20 21 22 23 24 ## 0.1672936363 0.9859583431 0.9745439489 0.9738080708 0.5622303983 0.8748321042 ## 25 26 27 28 29 30 ## 0.4560079466 0.2368433083 0.9860456411 0.7208455080 0.8093521595 0.1286310583 ## 31 32 33 34 35 36 ## 0.2209673461 0.4923424344 0.1597888373 0.2074205123 0.4804923276 0.1047615219 ## 37 38 39 40 41 42 ## 0.1468234813 0.0200046339 0.0015397957 0.1379815251 0.0502950337 0.1617730592 ## 43 44 45 46 47 48 ## 0.0088128566 0.0011890438 0.0171102995 0.0645145152 0.3411366744 0.0279131027 ## 49 50 51 52 53 54 ## 0.2159692960 0.0829690298 0.0525153673 0.0078621097 0.1098500760 0.0193729227 ## 55 56 57 58 59 60 ## 0.0682372458 0.0186736500 0.0052993359 0.2453448032 0.0026936317 0.0520999273 ## 61 62 63 64 65 66 ## 0.0043209522 0.0037861341 0.0406398167 0.0821545812 0.2640115440 0.0246819529 ## 67 68 69 70 ## 0.0001818862 0.0076395774 0.2645034420 0.1644306746 # All values are bound between 0 and 1. 6.1 The link function To move away from the traditional linear model and to avoid its biases, we need to specify two things when using a logistic regression: a distribution for the residuals of the model and a link function for the expected values. We already presented the Bernoulli distribution in the previous section so let’s have a look at what the link function is. In the case of a simple linear model of a normally distributed continuous response variable, the following equation gives the expected values: \\[ \\mu = X\\beta \\] where \\(\\mu\\) is the expected value of the response variable, \\(X\\) is the model matrix (i.e. representing your data) and \\(\\beta\\) corresponds to the parameters we estimate from the data (i.e. the intercept and the slope). The right-hand side of this equation is called the linear predictor. In mathematical terms, it is the matrix product of the model matrix \\(X\\) of a statistical model and the vector of estimated parameters \\(\\beta\\). Let’s have a look at this in R: # Load the CO2 dataset. We used it during workshop 4! data(CO2) head(CO2) ## Plant Type Treatment conc uptake ## 1 Qn1 Quebec nonchilled 95 16.0 ## 2 Qn1 Quebec nonchilled 175 30.4 ## 3 Qn1 Quebec nonchilled 250 34.8 ## 4 Qn1 Quebec nonchilled 350 37.2 ## 5 Qn1 Quebec nonchilled 500 35.3 ## 6 Qn1 Quebec nonchilled 675 39.2 Build a linear model of plant CO2 uptake as a function of CO2 ambient concentration. # Build the model model.CO2 &lt;- lm(uptake ~ conc, data = CO2) # Extract the design matrix of the model X &lt;- model.matrix(model.CO2) # And the estimated coefficients. B &lt;- model.CO2$coefficients # Let’s multiply both X and B matrices to obtain the linear predictor. # The &quot;%*%&quot; symbol indicates that it is a matrix product. XB &lt;- X %*% B # Compare the values of XB to the values obtained with the predict() function. # All statements should be TRUE. # We use the round() function so that all elements have 5 digits. round(fitted(model.CO2), digits = 5) == round(XB, digits = 5) ## [,1] ## 1 TRUE ## 2 TRUE ## 3 TRUE ## 4 TRUE ## 5 TRUE ## 6 TRUE ## 7 TRUE ## 8 TRUE ## 9 TRUE .... When using a simple linear model with a normally distributed response variable, the linear predictor is directly equal to the expected values of the model. But, what if our response variable is not normally distributed? If that is the case, we have to use a transformation on the expected values, i.e. a link function. A link function can be understood as a transformation of the expected values so that it can be linearly related to the linear predictor: \\[g(\\mu) = X\\beta\\] where \\(g(\\mu)\\) is the link function for the expected values. This allows us to relax the normality assumption. In the case of a binary response variable, the link function is called the logit function and is given by: logit(μ) = log (μ / 1-μ) = Xβ where μ represents expected values (i.e. the probability that Y = 1 because we observed the presence of a species, disease, success, or some other event). The ratio μ / 1-μ represents the odds that some outcome occured and it transforms the expected values into continuous values from 0 to infinity. If we have a 0.8 probability of observing species X, then our odds are 4 times more likely to observe the species than to not observe it: 0.8/(1-0.8) = 4. The log transformation, called the log odds, allows values to be spread across -infinity to infinity. Hence, the logit function took the expected values of a model and transformed them into continuous values without boundaries. The expected values can now be directly related to a linear predictor. This is why we still call this model a generalized linear model even though the plot of our response variable as a function of some explanatory variable doesn’t look like a “straight line”! # Let’s build a regression model of the presence/absence of a mite species (Galumna sp.) # as a function of water content and topography. # To do this, we need to use the glm() function and specify the family argument. logit.reg &lt;- glm(pa ~ WatrCont + Topo, data = mites, family = binomial(link = &quot;logit&quot;)) # The logit function is the default for the binomial distribution, # so it is not necessary to include it in the &quot;family&quot; argument: logit.reg &lt;- glm(pa ~ WatrCont + Topo, data = mites, family = binomial) summary(logit.reg) ## ## Call: ## glm(formula = pa ~ WatrCont + Topo, family = binomial, data = mites) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -2.0387 -0.5589 -0.1594 0.4112 2.0252 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 4.464402 1.670622 2.672 0.007533 ** ## WatrCont -0.015813 0.004535 -3.487 0.000489 *** ## TopoHummock 2.090757 0.735348 2.843 0.004466 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 91.246 on 69 degrees of freedom ## Residual deviance: 48.762 on 67 degrees of freedom ## AIC: 54.762 ## ## Number of Fisher Scoring iterations: 6 6.1.1 Challenge 1 Using the bacteria dataset (from the MASS package), model the presence of H. influenzae as a function of treatment and week of test. Start with a full model and reduce it to the most parsimonious model. Challenge 1: Solution data(bacteria) model.bact1 &lt;- glm(y ~ trt * week, family = binomial(&#39;logit&#39;), data = bacteria) model.bact2 &lt;- glm(y ~ trt + week, family = binomial(&#39;logit&#39;), data = bacteria) model.bact3 &lt;- glm(y ~ week, family = binomial(&#39;logit&#39;), data = bacteria) anova(model.bact1, model.bact2, model.bact3, test = &#39;LRT&#39;) ## Analysis of Deviance Table ## ## Model 1: y ~ trt * week ## Model 2: y ~ trt + week ## Model 3: y ~ week ## Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) ## 1 214 203.12 ## 2 216 203.81 -2 -0.6854 0.70984 ## 3 218 210.91 -2 -7.1026 0.02869 * ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 Based on these results, we select model #2 as the best candidate to model these data. 6.2 Interpreting the output of a logistic regression The output of the previous logistic regression indicates that both water content and topography are significant, but how do we interpret the slope coefficients? Remember that we applied a transformation on our expected values (i.e. the probability that Y = 1) so we have to use a reverse function to properly interpret the results. We can use the natural exponential function ex to obtain the odds of probability of success for each explanatory variable. logit.reg ## ## Call: glm(formula = pa ~ WatrCont + Topo, family = binomial, data = mites) ## ## Coefficients: ## (Intercept) WatrCont TopoHummock ## 4.46440 -0.01581 2.09076 ## ## Degrees of Freedom: 69 Total (i.e. Null); 67 Residual ## Null Deviance: 91.25 ## Residual Deviance: 48.76 AIC: 54.76 How to obtain the odds of the slope? Use the “exp()” function to put the coefficients back on the odds scale. Mathematically, this line of code corresponds to: exp(model coefficients) = exp(log(μ / (1 - μ)) = u / (1 - μ). This corresponds to an odds ratio! exp(logit.reg$coefficients[2]) ## WatrCont ## 0.9843118 To obtain confidence intervals on the odds scale: exp(confint(logit.reg)[2,]) ## 2.5 % 97.5 % ## 0.9741887 0.9919435 Note that the odds values here are considered when all other parameters are kept constant. The topography parameter value is 8.09. It means that the probability of observing Galumna sp. is 8.09 times more likely when the topography is hummock compared to blanket. When the odds value is smaller than 1, interpretation is a little bit more complicated. When this is the case, we have to take the inverse value (i.e. 1 divided by the odds) to facilitate interpretation. The interpretation is then how LESS likely it is to observe the event of interest. For water content, the odds is 0.984. The inverse is 1 / 0.984 = 1.0159. This means that a one-unit increase in water content decreases the likelihood of observing Galumna sp. by 1.0159. We can also substract 1 from the odds value to obtain a percentage: (1.0159 - 1) * 100 = 1.59% decrease in probability of observing Galumna sp. with a one-unit increase in water content. To convince ourselves that it is an appropriate interpretation, we can plot the presence of Galumna sp. as a function of water content. We see that, on average, Galumna sp. presence is higher at lower water content than its “absence”. When the parameter estimate is between 0 and 1 on the odds scales, it indicates a negative relationship between the response variable and the explanatory variable. If the parameter is greater than 1, it indicates a positive relationship between the response variable and the explanatory variable. If the confidence interval includes 1, it indicates that the variable is not significant. Remember that a value of 1 on the odds scale means that the probability of Y = 1 is the same as the probability of Y = 0 (i.e. when p = 0.5, 0.5/(1-0.5) = 1). If you want to obtain the probabilities instead of the odds for each explanatory variable, the inverse logit function is what you need: logit-1 = 1/(1+1/exp(x)) where x is the parameter to transform from log odds to the probability scale. The parameter estimate of topography in our logit.reg model is 2.091, which is on the log odds scale. So, the probability value is given by: 1/(1+1/exp(2.091)) = 0.89 which is the same as 1/(1+1/8.09). Remember that the value 8.09 is on the odds scale. We have a 0.89 probability of observing Galumna sp. when the topography is Hummock. Let’s calculate this probability without using the exp() function: First we start with our odds ratio for topography from the logit.reg model: µ/ (1 - µ) = 8.09 Let’s rearrange this to isolate µ µ = 8.09(1 - µ) = 8.09 - 8.09µ 8.09µ + µ = 8.09 µ(8.09 + 1) = 8.09 µ = 8.09 / (8.09 + 1) µ = 1 / (1 + (1 / 8.09)) = 0.89 We obtained the same result! 6.3 Predictive power and goodness-of-fit An easy and intuitive way to evaluate the predictive power of your model is to compare its deviance to the deviance of a null model. Deviance can be understood as a generalisation of the residual sum of squares when models are estimated by maximum likelihood (i.e. it is how parameters are estimated in GLM). This allows us to compute a pseudo-R2 statistic, which is analogous to the coefficient of determination R2 in ordinary least square regression (i.e. the basic method for linear models). The null model is a model without any explanatory variable. Its notation in R is: null.model &lt;- glm(Response.variable ~ 1, family = binomial). The generic formula to compute a pseudo-R2 is given by: Pseudo-R2 = (null deviance – residual deviance) / null deviance where “null deviance” is the deviance of the null model and “residual deviance” is the deviance of the model of interest. The difference is divided by the null deviance so that the result is bound between 0 and 1. # Residual and null deviances are already stored in the glm object. objects(logit.reg) ## [1] &quot;aic&quot; &quot;boundary&quot; &quot;call&quot; ## [4] &quot;coefficients&quot; &quot;contrasts&quot; &quot;control&quot; ## [7] &quot;converged&quot; &quot;data&quot; &quot;deviance&quot; ## [10] &quot;df.null&quot; &quot;df.residual&quot; &quot;effects&quot; ## [13] &quot;family&quot; &quot;fitted.values&quot; &quot;formula&quot; ## [16] &quot;iter&quot; &quot;linear.predictors&quot; &quot;method&quot; ## [19] &quot;model&quot; &quot;null.deviance&quot; &quot;offset&quot; ## [22] &quot;prior.weights&quot; &quot;qr&quot; &quot;R&quot; ## [25] &quot;rank&quot; &quot;residuals&quot; &quot;terms&quot; ## [28] &quot;weights&quot; &quot;xlevels&quot; &quot;y&quot; pseudoR2 &lt;- (logit.reg$null.deviance - logit.reg$deviance) / logit.reg$null.deviance pseudoR2 ## [1] 0.4655937 Hence, the model explains 46.6% of the variability in the data. An adjusted McFadden’s pseudo-R2, which penalizes for the number of predictors, can be calculated as below: where K corresponds to the additional number of predictors in relation to the null model. The goodness-of-fit of logistic regression models can be expressed by variants of pseudo-R2 statistics, such as Maddala (1983) or Cragg and Uhler (1970) measures. When talking about logistic regressions, low R2 values are common. The R function DescTools::PseudoR2() makes it possible to calculate many types of pseudo-R2. By specifying which = all, calculate all of them at once. logit.reg &lt;- glm(pa ~ WatrCont + Topo, data = mites, family = binomial(link = &quot;logit&quot;)) DescTools::PseudoR2(logit.reg, which = &quot;all&quot;) ## McFadden McFaddenAdj CoxSnell Nagelkerke AldrichNelson ## 0.4655937 0.3998373 0.4549662 0.6245898 0.3776866 ## VeallZimmermann Efron McKelveyZavoina Tjur AIC ## 0.6674318 0.5024101 0.7064093 0.5114661 54.7623962 ## BIC logLik logLik0 G2 ## 61.5078819 -24.3811981 -45.6229593 42.4835224 6.3.1 Challenge 2 Assess goodness-of-fit and predictive power of the model.bact2 model. How can you improve the predictive power of this model? Solution null.d &lt;- model.bact2$null.deviance resid.d &lt;- model.bact2$deviance bact.pseudoR2 &lt;- (null.d - resid.d) / null.d bact.pseudoR2 ## [1] 0.0624257 This is very low! Adding informative explanatory variables could increase the explanatory power of the model. But, do not be afraid of non-significant results! 6.4 Plotting results Once we’ve created a model and verified its validity, we can plot the results to show how the response variable is related to some explanatory variables. One way to graphically summarise the data is by plotting both the response variable and the expected values as a function of some predictor. Here is an example with the ggplot2 package. See workshop 3 for more information on this package. ggplot(mites, aes(x = WatrCont, y = pa)) + geom_point() + stat_smooth(method = &quot;glm&quot;, family= &quot;binomial&quot;, se = FALSE) + xlab(&quot;Water content&quot;) + ylab(&quot;Probability of presence&quot;) + ggtitle(&quot;Probability of presence of Galumna sp. as a function of water content&quot;) "],["binomial-glms.html", "Chapter 7 Binomial GLMS", " Chapter 7 Binomial GLMS Sometimes, proportion data are more similar to logistic regression than you think… In discrete counts, we can, for instance, measure the number of presence of individuals in relation to the total number of populations sampled. We will thus obtain a proportional number of “success” in observing individuals by dividing the counts by the total counts. In glm(), we have to provide prior weights if the response variable is the proportion of successes. Proportions can be modeled by providing both the number of “successes” and prior weights in the function prop.reg &lt;- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial) summary(prop.reg) ## ## Call: ## glm(formula = cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, ## family = binomial, data = mites) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.4808 -0.9699 -0.6327 -0.1798 4.1688 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.288925 0.422109 -7.792 6.61e-15 *** ## TopoHummock 0.578332 0.274928 2.104 0.0354 * ## WatrCont -0.005886 0.001086 -5.420 5.97e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 140.702 on 69 degrees of freedom ## Residual deviance: 85.905 on 67 degrees of freedom ## AIC: 158.66 ## ## Number of Fisher Scoring iterations: 5 The weights can also be set explicitly in glm(): prop.reg2 &lt;- glm(prop ~ Topo + WatrCont, data = mites, family = binomial, weights = totalabund) summary(prop.reg2) ## ## Call: ## glm(formula = prop ~ Topo + WatrCont, family = binomial, data = mites, ## weights = totalabund) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.4808 -0.9699 -0.6327 -0.1798 4.1688 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) -3.288925 0.422109 -7.792 6.61e-15 *** ## TopoHummock 0.578332 0.274928 2.104 0.0354 * ## WatrCont -0.005886 0.001086 -5.420 5.97e-08 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for binomial family taken to be 1) ## ## Null deviance: 140.702 on 69 degrees of freedom ## Residual deviance: 85.905 on 67 degrees of freedom ## AIC: 158.66 ## ## Number of Fisher Scoring iterations: 5 "],["what-can-we-do-with-count-data.html", "Chapter 8 What can we do with count data?", " Chapter 8 What can we do with count data? To illustrate count data we will use a new dataset called faramea. faramea &lt;- read.csv(&quot;faramea.csv&quot;, header = TRUE) In this dataset, the number of trees of the species Faramea occidentalis was measured in 43 quadrats in Barro Colorado Island in Panama. For each quadrat, environmental characteristics were also recorded such as elevation or precipitation. Let’s take a look at the number of Faramea occidentalis found at each quadrat. hist(faramea$Faramea.occidentalis, breaks=seq(0,45,1), xlab=expression(paste(&quot;Number of &quot;, italic(Faramea~occidentalis))), ylab=&quot;Frequency&quot;, main=&quot;&quot;, col=&quot;grey&quot;) We can see that there are only positive and integer values. Given these specificities, the Poisson distribution, described above, seems to be the perfect choice to model this data. "],["poisson-glms.html", "Chapter 9 Poisson GLMs 9.1 The problem of overdispersion", " Chapter 9 Poisson GLMs As we saw above, the Poisson distribution is particularly relevant to model count data because it: specifies the probably only for integer values P(y&lt;0) = 0, hence the probability of any negative value is null the mean-variance relationship allows for heterogeneity (e.g. when variance generally increases with the mean) In this example, we want to test whether elevation (a continuous explanatory variable) influences Faramea occidentalis abundance. Hence, a Poisson GLM (i.e. a simple Poisson regression) seems to be a good choice to model the number of Faramea occidentalis as a function of elevation. Poisson GLMs are usually a good way to start modeling count data. But what does a Poisson GLM do? It assumes that the response variables yi have been generated by a Poisson distribution with mean and variance µi. Yi ∼ Poisson(µi) with E(Yi) = Var(Yi) = µi Recall from above that µi can be replaced the systematic model Yi ~ Poisson(β0 + β1Xi) A systematic part is used as a linear combination of unknown parameters β representing the effects of different explanatory variables. X is the covariate matrix (which does not include an intercept term in this example). This systemtatic part is define as: β0 + Xi*β The mean of the distribution µi is related to the systematic part using a logarithm link function. As a result, the relationship between the mean and the linear predictor is log-linear. log(µi) = β0 + Xi*β or µi = exp(β0 + Xi*β) The Poisson distribution gives you the probability that a particular Yi value is observed for a given mean µi = exp(β0 + Xi*β). In this model, the unknown parameters are included in the vector of regression coefficients β (plus the intercept β0) and can be estimated using maximum-likelihood (ML) estimation. Fitting a Poisson GLM in R requires only setting family = poisson in the function glm(). By default the link function is log. glm.poisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=poisson) summary(glm.poisson) ## ## Call: ## glm(formula = Faramea.occidentalis ~ Elevation, family = poisson, ## data = faramea) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -3.3319 -2.7509 -1.5451 0.1139 11.3995 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 1.7687001 0.1099136 16.092 &lt; 2e-16 *** ## Elevation -0.0027375 0.0006436 -4.253 2.11e-05 *** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for poisson family taken to be 1) ## ## Null deviance: 414.81 on 42 degrees of freedom ## Residual deviance: 388.12 on 41 degrees of freedom ## AIC: 462.01 ## ## Number of Fisher Scoring iterations: 10 The output is similar to a ‘lm’ output (see workshop 4) and gives you the parameter estimates which can also be retrieved using other functions: # intercept summary(glm.poisson)$coefficients[1,1] ## [1] 1.7687 # slope of elevation summary(glm.poisson)$coefficients[2,1] ## [1] -0.002737509 9.1 The problem of overdispersion An important aspect of the summary can be found in the last lines. ## Null deviance: 414.81 on 42 degrees of freedom ## Residual deviance: 388.12 on 41 degrees of freedom Remember that ML estimation is used to estimate the parameters. In the goodness-of-fit section we mentioned that the deviance was a ML equivalent of the sum of squares in linear models. Here, the null deviance and the residual deviance are equivalent to the total sum of squares and the residual sum of squares respectively. The residual deviance is defined as twice the difference between the log likelihood of a model that provides a perfect fit to the data (a saturated model) and the log likelihood of the model. If our model is correct the asymptotic distribution of the residual deviance is approximated using χ² distribution with n-p-1 degrees of freedom (computed as n-p-1, where n is the number of observations and p the number of covariates). This implies that residual deviance should be equal to the residual degrees of freedom. In our example, the residual deviance equals 388.12 while we have 41 (43-1-1) degrees of freedom. This former is greater to the former by 9.5 times, the model is then overdispersed. Overdispersion As a consequence overdispersion can be computed for any model using the parameter φ: φ = residual deviance / residual degrees of freedom * φ &lt; 1 indicates underdispersion * φ = 1 indicates no overdispersion * φ &gt; 1 indicates overdispersion Why does a Poisson GLM exhibit overdispersion? This arises when the variance of the data is higher than expected from the Poisson distribution. This frequently occurs when data includes many zeros and/or many very high values. Looking back at the distribution of our data (above) suggests that our data contains many zero preventing us to use a Poisson GLM. Overdispersion may also result from missing covariates, missing interaction terms or presence of strong outliers, preventing us from using a Poisson GLM. The Poisson distribution can account only partially for heterogeneity in the data due to the mean variance relationship, but in some cases variance increases even higher than the mean. Computing the mean and the variance of our dataset suggests this is occurring: mean(faramea$Faramea.occidentalis) var(faramea$Faramea.occidentalis) In practice, Poissons GLM are useful for describing the mean µi but underestimates the variance in the data, making all model-based tests too liberal! There are two ways of dealing with overdispersion and will be developed below: correct for it by doing a quasi-Poisson GLM choose another distribution such as the negative binomial "],["quasi-poisson-glms.html", "Chapter 10 Quasi-Poisson GLMs", " Chapter 10 Quasi-Poisson GLMs The principle behind a quasi-Poisson GLM is very simple; the overdispersion parameter (φ) is added to the expected variance equation: E(Yi) = µi Var(Yi) = φ.µi The systematic part and the link function remains the same. The difference is that φ will first be estimated to correct the model. Parameter Estimates will be the same but the standard errors of the parameters are multiplied by √φ, in other terms, some marginally significant p-values may no longer hold. In R, The quasipoisson family object can be used to deal with count data exhibiting overdispersion (the quasibinomial family object can do the same for binomial data). The fitted φ value will be returned in the summary of the GLM. There are two ways to perform this GLM: # Option 1, fit a new quasi-Poisson GLM glm.quasipoisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=quasipoisson) # Option 2, build from the previous model and update it: glm.quasipoisson = update(glm.poisson,family=quasipoisson) # output summary(glm.quasipoisson) ## ## Call: ## glm(formula = Faramea.occidentalis ~ Elevation, family = quasipoisson, ## data = faramea) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -3.3319 -2.7509 -1.5451 0.1139 11.3995 ## ## Coefficients: ## Estimate Std. Error t value Pr(&gt;|t|) ## (Intercept) 1.768700 0.439233 4.027 0.000238 *** ## Elevation -0.002738 0.002572 -1.064 0.293391 ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for quasipoisson family taken to be 15.96936) ## ## Null deviance: 414.81 on 42 degrees of freedom ## Residual deviance: 388.12 on 41 degrees of freedom ## AIC: NA ## ## Number of Fisher Scoring iterations: 10 If you look at the summary of the model you will see that φ is estimated as 15.97. We then made a good choice by updating the model to account for overdispersion. However if we look at P-values we can note that elevation is no longer significant. Yet, 15.97 is quite a lot of overdispersion, and in general quasi-Poisson GLMs will be favoured when φ is included between 1 and 15 though these limits are arbitrary. When overdispersion is higher than 15-20 we recommend moving to the negative binomial. For the sake of pedagogy, we will consider that we are not happy with this model to fit a final negative-binomial GLM to our data. Two other points are important to keep in mind when using quasi-Poisson GLMs and dealing with overdispersion: Quasi-Poisson GLMs do not have AIC scores. An important aspect is that quasi-Poisson GLMs do not correspond to models with fully specified likelihoods and rely on quasi-ML estimation (i.e. pseudolikelihood). One consequence is that quasi-Poisson GLMs do not have AIC scores for model comparisons. However, variants of AIC have been developed to deal with this situation (e.g. quasi-AIC). Overdispersion affects model comparison. Indeed overdispersion also influences the comparison of two nested models and has to be taken into account when φ is known. For instance, let’s assume that we want to compare GLM1, with p1 parameters to GLM2, with p2 parameters, such that GLM1 is nested within GLM2 and p2 &gt; p1. Model comparison is achieved based on a generalized likelihood ratio test, which can be written as a function of the difference of deviances between the two GLMs, D1 and D2 respectively. If Overdispersion is known, deviances have to be scaled (i.e. corrected) accordingly as D* = D/φ. The final test will be based on the criterion D1* - D*2 which is assumed to follow a χ² distribution with p2-p1 degrees of freedom when GLM1 is correct. In some cases φ is not known. For instance, this occurs when you run a GLM with a normal error distribution. In that case, φ can be estimated a posteriori using the residual deviance of the larger model so the criterion becomes [(D1-D2)/(p2-p1)]/[D2/(n-p2)] and is assumed to follow a F distribution with p2-p1 and n-p2 degrees of freedom. Try also deviance analysis to test for the effect of Elevation null.model &lt;- glm(Faramea.occidentalis ~ 1, data = faramea, family = quasipoisson) anova(null.model, glm.quasipoisson, test = &quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model 1: Faramea.occidentalis ~ 1 ## Model 2: Faramea.occidentalis ~ Elevation ## Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) ## 1 42 414.81 ## 2 41 388.12 1 26.686 0.1961 Dispersion parameter: "],["negative-binomial-glms.html", "Chapter 11 Negative binomial GLMs 11.1 Plotting the final GLM to the data", " Chapter 11 Negative binomial GLMs GLM with a negative binomial (NB) distribution are favored when overdispersion is extreme. The NB distribution contains an additional parameter k, particularly handy for count data containing a preponderance of zeros. Before we go into R stuff, we should see what lies behind a negative binomial GLM. A NB distribution is actually a combination of two distributions: a Poisson distribution and a gamma distribution. The NB distribution first assumes that a discrete random variable is Poisson distributed but its mean, µ is assumed to follow a gamma distribution. The mixture between the Poisson and gamma distributions can be simplified into a density function specific to the NB which has two parameters µ and k. Y ~ NB(µ, k) E(Y) = µ and Var(Y) = µ + µ²/k Here, we can see how overdispersion will be accounted for by NB distribution in GLMs. The second term of the variance determines the amount of overdispersion. In fact, it is indirectly determined by k, where k is also called the dispersion parameter. If k is large (relative to μ²), the second term, µ²/k approximates 0, and the variance of Y is μ. In such cases the NB converges to the Poisson distribution and you might as well use a Poisson distribution. The smaller k, the larger the overdispersion. Just like with others GLMs, a NB GLM is specified following the fundamental three steps. It first assumes that Yi is negative binomial distributed with mean μi and parameter k. Yi ∼ NB(µi, k) E(Yi) = µi and Var(Yi) = µi + µi²/k The two last steps define the systematic part and the link function between the mean of Yi and the predictor function. In NB GLMs the link function is logarithmic ensuring that fitted values are always positive. log(µi) = β0 + Xi.β or µi = exp(β0 + Xi.β) The negative binomial GLM can be built using the glm.nb() function from the MASS package: glm.negbin = glm.nb(Faramea.occidentalis~Elevation, data=faramea) summary(glm.negbin) ## ## Call: ## glm.nb(formula = Faramea.occidentalis ~ Elevation, data = faramea, ## init.theta = 0.2593107955, link = log) ## ## Deviance Residuals: ## Min 1Q Median 3Q Max ## -1.36748 -1.17564 -0.51338 -0.05226 2.25716 ## ## Coefficients: ## Estimate Std. Error z value Pr(&gt;|z|) ## (Intercept) 2.369226 0.473841 5.00 5.73e-07 *** ## Elevation -0.007038 0.002496 -2.82 0.00481 ** ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 ## ## (Dispersion parameter for Negative Binomial(0.2593) family taken to be 1) ## ## Null deviance: 41.974 on 42 degrees of freedom ## Residual deviance: 36.343 on 41 degrees of freedom ## AIC: 182.51 ## ## Number of Fisher Scoring iterations: 1 ## ## ## Theta: 0.2593 ## Std. Err.: 0.0755 ## ## 2 x log-likelihood: -176.5090 The summary is similar to other GLMs summaries (e.g. Poisson GLMs), though we now have a parameter theta, which stands for parameter k in the variance of the NB distribution. Its standard error is also provided, but care is needed with its use as the interval is not symmetric and we are testing on the boundary. 11.1 Plotting the final GLM to the data The NB GLMs appear to be the best fit to our data. We can plot the relationship between the abundance of Faramea occidentalis and elevation. Use summary to get the parameters. summary(glm.negbin)$coefficients[1, 1] ## [1] 2.369226 summary(glm.negbin)$coefficients[2, 1] ## [1] -0.007038124 Use the standard errors to build the confidence envelope. summary(glm.negbin)$coefficients[1, 2] ## [1] 0.4738409 summary(glm.negbin)$coefficients[2, 2] ## [1] 0.002496143 pp &lt;- predict(glm.negbin, newdata = data.frame(Elevation = 1:800), se.fit = TRUE) linkinv &lt;- family(glm.negbin)$linkinv ## inverse-link function pframe &lt;- as.data.frame(pp$fit) names(pframe) &lt;- &quot;pred0&quot; pframe$pred &lt;- linkinv(pp$fit) sc &lt;- abs(qnorm((1-0.95)/2)) ## Normal approx. to likelihood pframe &lt;- transform(pframe, lwr = linkinv(pred0-sc*pp$se.fit), upr = linkinv(pred0+sc*pp$se.fit)) plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = &#39;Number of F. occidentalis&#39;, xlab = &#39;Elevation(m)&#39;) lines(pframe$pred, lwd = 2) lines(pframe$upr, col = 2, lty = 3, lwd = 2) lines(pframe$lwr, col = 2, lty = 3, lwd = 2) We can see that the number of Faramea occidentalis significantly decreases with elevation. However, the confidence envelope of the NB model is large at low elevation. 11.1.1 Challenge 3 Use the mites dataset! Model the abundance of the species Galumna as a function of the substrate characteristics (water content WatrCont and density SubsDens) Do you need to account for overdispersion? Which covariates have a significant effect? Select the best model! mites &lt;- read.csv(&quot;data/mites.csv&quot;, header = TRUE) Drop each term in turn and compare the full model with a nested model using the command: drop1(MyGLM, test = &quot;Chi&quot;) Specify manually a nested model, call it for example MyGLM2, and use the command: anova(MyGLM, MyGLM2, test = &quot;Chi&quot;) Solution # Poisson GLM glm.p = glm(Galumna~WatrCont+SubsDens, data=mites, family=poisson) # quasi-Poisson GLM glm.qp = update(glm.p,family=quasipoisson) # model selection drop1(glm.qp, test = &quot;Chi&quot;) ## Single term deletions ## ## Model: ## Galumna ~ WatrCont + SubsDens ## Df Deviance scaled dev. Pr(&gt;Chi) ## &lt;none&gt; 101.49 ## WatrCont 1 168.10 31.711 1.789e-08 *** ## SubsDens 1 108.05 3.125 0.07708 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 # or glm.qp2 = glm(Galumna~WatrCont, data=mites, family=quasipoisson) anova(glm.qp2, glm.qp, test=&quot;Chisq&quot;) ## Analysis of Deviance Table ## ## Model 1: Galumna ~ WatrCont ## Model 2: Galumna ~ WatrCont + SubsDens ## Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi) ## 1 68 108.05 ## 2 67 101.49 1 6.5657 0.07708 . ## --- ## Signif. codes: 0 &#39;***&#39; 0.001 &#39;**&#39; 0.01 &#39;*&#39; 0.05 &#39;.&#39; 0.1 &#39; &#39; 1 "],["conclusion-on-glms-with-count-data.html", "Chapter 12 Conclusion on GLMs with count data", " Chapter 12 Conclusion on GLMs with count data All the GLMs introduced (Poisson, quasi-Poisson and NB) to model count data use the same log-linear mean function (log(µ) = X.β), but make different assumptions about the remaining likelihood. Quasi-Poisson and NB are favored to deal with overdispersion. However, in some cases the data may contains too many zeros and zero-augmented models can be useful as they extend the mean function by modifying (typically, increasing) the likelihood of zero counts (e.g. zero-inflated Poisson [ZIP]). "],["other-distributions.html", "Chapter 13 Other distributions", " Chapter 13 Other distributions When the response variable consists of percentages or proportions that do not arise from successes and failures from n yes/no experiments (Bernoulli experiment), it is not possible to use the binomial distribution. In this case, it is often advised to perform a logit transformation of the data and use a lm(m). See this interesting article. For data that can be appear normally distributed after a log-transformation, it can be advisable to use a log-normal distribution in a glm instead of log-transforming the data. A Gamma distribution can also be used. It is similar to a log-normal distribution, but is more versatile. The Tweedie distribution is a versatile family of distributions that is useful for data with a mix of zeros and positive values (not necessarily counts). See the R Tweedie package. When the data comprise an excess number of zeros, that arise from a different process than the process that generates the counts, the zero-inflated Poisson or zero-inflated negative binomial distributions should be used. These methods are available, in the glmmADMB package, among others. "],["summary.html", "Chapter 14 Summary", " Chapter 14 Summary GLMs are a powerful statistical tecnhique for … In the next workshop, you will see … "],["additional-resources.html", "Chapter 15 Additional resources", " Chapter 15 Additional resources "],["references.html", "Chapter 16 References", " Chapter 16 References "]]
