# (PART\*) GLMs with binary data {-}

# Binomial GLMs (Bernouilli)

A common response variable in ecological datasets is the binary
variable: we observe a phenomenon X or its "absence". For example,
species presence/absence is frequently recorded in ecological monitoring
studies. We usually wish to determine whether a species' presence is
affected by some environmental variables. Other examples include the
presence/absence of a disease within a wild population, the
success/failure to record a specific behaviour, and the survival/death
of organisms. A regression that has a binary response variable is one of
many generalized linear models and is called a logistic regression or a
logit model.

In R, presence (or success, survival...) is usually coded as 1 and
absence (or failure, death...) as 0. A logistic regression (or any other
generalized linear model) is performed with the `glm()` function. This
function is different from the basic `lm()` as it allows one to specify
a statistical distribution other than the normal distribution. We've
already seen that binary variables are not normally distributed (*i.e.*
we see a peak at 0 and a peak at 1 and nothing in between). Like we have
seen in the previous section, the Bernoulli distribution is well suited
for binary response variables. The mean of this distribution is the
probability *p* of observing an outcome and the variance is *p*\*(1 -
*p*). The (1 - *p*) term represents the probability of **not** observing
an outcome. In R, we specify the distribution with the `family`
argument. For the logistic regression, we code it as:
`family='binomial`'. Remember that the Bernoulli distribution is a
special case of the binomial distribution when the number of repetitions
is 1: R will "understand" that it is a Bernoulli distribution.

When predicting the probability of observing some phenomenon Y, which is
a binary variable, the expected values should be bound between 0 and 1:
that's the range of a probability value! If we use a basic linear model
to relate a binary response variable to various explanatory variables,
we might obtain fitted values outside of the \[0,1\] range, which is
nonsensical. The following example will help you understand why a basic
linear model is inappropriate here. The next subsection will show you
how to avoid this problem with a link function. Briefly, a link function
is used to linearize the relationship between predicted values of the
response variable and the linear predictor (see next subsection).

```{r, echo = TRUE, eval = FALSE}
model.lm <- lm(pa ~ WatrCont + Topo, data = mites)
fitted(model.lm)
# The "fitted()" function gives us expected values for the response variable.
# Some values are lower than 0, which does not make sense for a logistic regression.
# Let’s try the same model with a binomial distribution instead.
# Notice the "family" argument to specify the distribution.
model.glm <- glm(pa ~ WatrCont + Topo, data = mites, family = binomial)
fitted(model.glm)
# All values are bound between 0 and 1.
```

## The link function

To move away from the traditional linear model and to avoid its biases,
we need to specify two things when using a logistic regression: a
distribution for the residuals of the model and a link function for the
expected values. We already presented the Bernoulli distribution in the
previous section so let's have a look at what the link function is.

In the case of a simple linear model of a normally distributed
continuous response variable, the following equation gives the expected
values:

*μ* = *Xβ*

where *μ* is the expected value of the response variable, *X* is the
model matrix (*i.e.* representing your data) and *β* corresponds to the
parameters we estimate from the data (*i.e.* the intercept and the
slope). The right-hand side of this equation is called the linear
predictor. In mathematical terms, it is the matrix product of the model
matrix *X* of a statistical model and the vector of estimated parameters
*β*. Let's have a look at this in R:

```{r, echo = TRUE, eval = FALSE}
# Load the CO2 dataset. We used it during workshop 4!
data(CO2)
head(CO2)
# Build a linear model of plant CO2 uptake as a function of CO2 ambient concentration
model.CO2 <- lm(uptake ~ conc, data = CO2)
# Extract the design matrix of the model with the model.matrix() function.
X <- model.matrix(model.CO2)
# And the estimated coefficients.
B <- model.CO2$coefficients
# Let’s multiply both X and B matrices to obtain the linear predictor.
# The "%*%" symbol indicates that it is a matrix product.
XB <- X %*% B
# Compare the values of XB to the values obtained with the predict() function.
# All statements should be TRUE.
# We use the round() function so that all elements have 5 digits.
round(fitted(model.CO2), digits = 5) == round(XB, digits = 5)
```

When using a simple linear model with a normally distributed response
variable, the linear predictor is directly equal to the expected values
of the model. But, what if our response variable is not normally
distributed? If that is the case, we have to use a transformation on the
expected values, *i.e.* a link function. A link function can be
understood as a transformation of the expected values so that it can be
**linearly related** to the linear predictor:

*g*(*μ*) = *Xβ*

where *g*(*μ*) is the link function for the expected values. This allows
us to relax the normality assumption. In the case of a binary response
variable, the link function is called the logit function and is given
by:

logit(*μ*) = log (*μ* / 1-*μ*) = *Xβ*

where *μ* represents expected values (*i.e.* the probability that Y = 1
because we observed the presence of a species, disease, success, or some
other event). The ratio *μ* / 1-*μ* represents the odds that some
outcome occured and it transforms the expected values into continuous
values from 0 to infinity. If we have a 0.8 probability of observing
species X, then our odds are 4 times more likely to observe the species
than to not observe it: 0.8/(1-0.8) = 4. The log transformation, called
the log odds, allows values to be spread across -infinity to infinity.
Hence, the logit function took the expected values of a model and
transformed them into continuous values without boundaries. The expected
values can now be directly related to a linear predictor. This is why we
still call this model a generalized **linear** model even though the
plot of our response variable as a function of some explanatory variable
doesn't look like a "straight line"!

```{r, echo = TRUE, eval = FALSE}
# Let’s build a regression model of the presence/absence of a mite species (Galumna sp.)
# as a function of water content and topography.
# To do this, we need to use the glm() function and specify the family argument.
logit.reg <- glm(pa ~ WatrCont + Topo, data = mites, family = binomial(link = "logit"))
# The logit function is the default for the binomial distribution,
# so it is not necessary to include it in the "family" argument:
logit.reg <- glm(pa ~ WatrCont + Topo, data = mites, family = binomial)
summary(logit.reg)
```

### Challenge 1

Using the `bacteria` dataset (from the `MASS` package), model the
presence of *H. influenzae* as a function of treatment and week of test.
Start with a full model and reduce it to the most parsimonious model.

Challenge 1: Solution

```{r, echo = TRUE, eval = FALSE}
model.bact1 <- glm(y ~ trt * week, family = binomial('logit'), data = bacteria)
model.bact2 <- glm(y ~ trt + week, family = binomial('logit'), data = bacteria)
model.bact3 <- glm(y ~ week, family = binomial('logit'), data = bacteria)
anova(model.bact1, model.bact2, model.bact3, test = 'LRT')
# Analysis of Deviance Table
# Model 1: y ~ trt * week
# Model 2: y ~ trt + week
# Model 3: y ~ week
#   Resid. Df Resid. Dev Df Deviance Pr(>Chi)
# 1       214     203.12
# 2       216     203.81 -2  -0.6854  0.70984
# 3       218     210.91 -2  -7.1026  0.02869 *
#Based on these results, we select model #2 as the best candidate to model these data.
```

## Interpreting the output of a logistic regression

The output of the previous logistic regression indicates that both water
content and topography are significant, but how do we interpret the
slope coefficients? Remember that we applied a transformation on our
expected values (*i.e.* the probability that Y = 1) so we have to use a
reverse function to properly interpret the results. We can use the
natural exponential function `ex` to obtain the odds of probability of
success for each explanatory variable.

```{r, echo = TRUE, eval = FALSE}
# Obtaining the odds of the slope.
# Use the "exp()" function to put the coefficients back on the odds scale.
# Mathematically, this line of code corresponds to:
# exp(model coefficients) = exp(log(μ / (1 - μ)) = u / (1 - μ)
# This corresponds to an odds ratio!
exp(logit.reg$coefficients[2:3])
#  WatrCont    TopoHummock
#  0.9843118   8.0910340
# To obtain confidence intervals on the odds scale:
exp(confint(logit.reg)[2:3,])
#               2.5 %      97.5 %
#  WatrCont     0.9741887  0.9919435
#  TopoHummock  2.0460547  38.6419693
```

Note that the odds values here are considered when all other parameters
are kept constant. The topography parameter value is 8.09. It means that
the probability of observing *Galumna* sp. is 8.09 times more likely
when the topography is hummock compared to blanket.

When the odds value is smaller than 1, interpretation is a little bit
more complicated. When this is the case, we have to take the inverse
value (*i.e.* 1 divided by the odds) to facilitate interpretation. The
interpretation is then how **LESS** likely it is to observe the event of
interest. For water content, the odds is 0.984. The inverse is 1 / 0.984
= 1.0159. This means that a one-unit increase in water content decreases
the likelihood of observing *Galumna* sp. by 1.0159. We can also
substract 1 from the odds value to obtain a percentage: (1.0159 - 1) \*
100 = 1.59% decrease in probability of observing *Galumna* sp. with a
one-unit increase in water content. To convince ourselves that it is an
appropriate interpretation, we can plot the presence of *Galumna* sp. as
a function of water content. We see that, on average, *Galumna* sp.
presence is higher at lower water content than its "absence".

![](images/galumna_pa.png){width="400"}

When the parameter estimate is between 0 and 1 on the odds scales, it
indicates a negative relationship between the response variable and the
explanatory variable. If the parameter is greater than 1, it indicates a
positive relationship between the response variable and the explanatory
variable. If the confidence interval includes 1, it indicates that the
variable is not significant. Remember that a value of 1 on the odds
scale means that the probability of Y = 1 is the same as the probability
of Y = 0 (*i.e.* when p = 0.5, 0.5/(1-0.5) = 1).

If you want to obtain the probabilities instead of the odds for each
explanatory variable, the inverse logit function is what you need:

logit^-1^ = 1/(1+1/exp(x))

where x is the parameter to transform from log odds to the probability
scale. The parameter estimate of topography in our `logit.reg` model is
2.091, which is on the log odds scale. So, the probability value is
given by:

1/(1+1/exp(2.091)) = 0.89 which is the same as 1/(1+1/8.09). Remember
that the value 8.09 is on the odds scale. We have a 0.89 probability of
observing *Galumna* sp. when the topography is Hummock.

```{r, echo = TRUE, eval = FALSE}
# Let's start with our odds ratio for topography from the logit.reg model:
µ/ (1 - µ) = 8.09
# Let's rearrange this to isolate µ
µ = 8.09(1 - µ) = 8.09 - 8.09µ
8.09µ + µ = 8.09
µ(8.09 + 1) = 8.09
µ = 8.09 / (8.09 + 1)
µ = 1 / (1 + (1 / 8.09)) = 0.89
# We obtained the same result without using the exp() function!
```

## Predictive power and goodness-of-fit

An easy and intuitive way to evaluate the predictive power of your model
is to compare its deviance to the deviance of a null model. Deviance can
be understood as a generalisation of the residual sum of squares when
models are estimated by maximum likelihood (i.e. it is how parameters
are estimated in GLM). This allows us to compute a pseudo-R^2^
statistic, which is analogous to the coefficient of determination R^2^
in ordinary least square regression (i.e. the basic method for linear
models). The null model is a model without any explanatory variable. Its
notation in R is:
`null.model <- glm(Response.variable ~ 1, family = binomial)`. The
generic formula to compute a pseudo-R^2^ is given by:

Pseudo-R^2^ = (null deviance -- residual deviance) / null deviance

where "null deviance" is the deviance of the null model and "residual
deviance" is the deviance of the model of interest. The difference is
divided by the null deviance so that the result is bound between 0 and
1.

```{r, echo = TRUE, eval = FALSE}
# Residual and null deviances are already stored in the glm object.
objects(logit.reg)
pseudoR2 <- (logit.reg$null.deviance – logit.reg$deviance) / logit.reg$null.deviance
pseudoR2
# [1]  0.4655937
```

Hence, the model explains 46.6% of the variability in the data.

Recently, [Tjur
(2009)](http://www.tandfonline.com/doi/abs/10.1198/tast.2009.08210#.VFpKZYcc4ow)
proposed a new statistic, the coefficient of discrimination (*D*), to
evaluate the predictive power of logistic regression models.
Intuitively, *D* is a measure of how well a logistic regression can
classify an outcome as a success or a failure. In mathematical terms, it
is the difference between the means of expected probability values for
successes (*i.e.* Y =1) and failures (*i.e.* Y = 0):

\<m\>D = overline{π}\_1 - overline{π}\_0\</m\>

where \<m\>overline{π}\_1\</m\> is the mean of expected probability
values when the outcome is observed and \<m\>overline{π}\_0\</m\> is the
mean of expected probability values when the outcome is not observed. A
*D* value close to 1 indicates that the model gives a high probability
of observing an outcome to cases where the outcome was actually observed
and a low probability of observing an outcome to cases where the outcome
was not observed. A *D* value close to 0 indicates that the model is not
efficient at discriminating between the occurrences and "non
occurrences" of an outcome. The following code shows how to obtain *D*
and how to plot the histograms of \<m\>overline{π}\_1\</m\> and
\<m\>overline{π}\_0\</m\>.

```{r, echo = TRUE, eval = FALSE}
install.packages("binomTools")
library("binomTools")
# The Rsq function computes several fit indices,
# including the coefficient of discrimination.
# For information on the other fit indices, see Tjur (2009).
# The plot shows the distribution of expected values when the outcome is observed
# and not observed.
# Ideally, the overlap between the two histograms should be small.
fit <- Rsq(object = logit.reg)
fit
# R-square measures and the coefficient of discrimination, 'D':
#
#    R2mod     R2res     R2cor     D
#    0.5205221 0.5024101 0.5025676 0.5114661
#
# Number of binomial observations:  70
# Number of binary observation:  70
# Average group size:  1
plot(fit, which = "hist")
```

To assess the goodness-of-fit of a logistic regression, the diagnostic
plots (see workshop 4) are not useful. Instead, you can do a
[Hosmer-Lemeshow
test](http://en.wikipedia.org/wiki/Hosmer-Lemeshow_test) to evaluate
whether your model is appropriate. This test separates the expected
values (ordered from smallest to largest) in groups of approximately
equal size. Ten is usually the recommended group number. In each group,
we compare the observed and expected number of outcomes. It is similar
to a chi-square test with G - 2 degrees of freedom (G is the number of
groups). In R, this test is available in the `binomTools` package.

```{r, echo = TRUE, eval = FALSE}
fit <- Rsq(object = logit.reg)
HLtest(object = fit)
# The p value is 0.9051814. Hence, we do not reject the model.
# We can consider it as appropriate for the data.
```

### Challenge 2

Assess goodness-of-fit and predictive power of the `model.bact2` model. How can you improve the predictive power of this model?

Challenge 2: Solution

```{r, echo = TRUE, eval = FALSE}
null.d <- model.bact2$null.deviance
resid.d <- model.bact2$deviance
bact.pseudoR2 <- (null.d - resid.d) / null.d
bact.pseudoR2
# 0.0624257
# This is very low!
library(binomTools)
HLtest(Rsq(model.bact2))
# Chi-square statistic:  7.812347  with  8  df
# P-value:  0.4520122
# Fit is adequate.
```

Predictive power could be increased by including more relevant explanatory varibles. 

## Plotting results

Once we've created a model and verified its validity, we can plot the
results to show how the response variable is related to some explanatory
variables. One way to graphically summarise the data is by plotting both
the response variable and the expected values as a function of some
predictor. Here is an example with the `ggplot2` package. See [workshop
3](r_workshop3) for more information on this package.

```{r, echo = TRUE, eval = FALSE}
library(ggplot2)
ggplot(mites, aes(x = WatrCont, y = pa)) + geom_point() +
stat_smooth(method = "glm", family= "binomial", se = FALSE) + xlab("Water content") +
ylab("Probability of presence") +
ggtitle("Probability of presence of Galumna sp. as a function of water content")
```

![](images//logistic_regression_plot.png){width="500"}