---
title: "Atelier 6: Mod√®les lin√©aires g√©n√©ralis√©s"
subtitle: "S√©rie d'ateliers R"
author: "Centre de la Science de la Biodiversit√© du Qu√©bec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
      highlightStyle: github
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  cache = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width=6, fig.height=6,
  fig.retina = 3,
  fig.align = 'center'
)
mypar = list(mar = c(3,3,1,0.5), mgp = c(1.6, 0.3, 0), tck = -.02)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```


class: inverse, center, middle

```{r install_pkgs, message=FALSE, warning=FALSE, include=FALSE, results=0}
# Standard procedure to check and install packages and their dependencies, if needed.

list.of.packages <- c('ggplot2', 'lme4', 'MASS', 'vcdExtra', 'bbmle', 'DescTools')

new.packages <- list.of.packages[!(list.of.packages %in% installed.packages()[,"Package"])]

if(length(new.packages) > 0) {
  install.packages(new.packages, dependencies = TRUE) 
  print(paste0("The following package was installed:", new.packages)) 
} else if(length(new.packages) == 0) {
    print("All packages were already installed previously")
  }
```

# √Ä propos de cet atelier

[![badge](https://img.shields.io/static/v1?style=flat-square&label=Diapos&message=07&color=red&logo=html5)](https://qcbsrworkshops.github.io/workshop06/pres-fr/workshop06-pres-fr.html)
[![badge](https://img.shields.io/static/v1?style=flat-square&label=livre&message=07&logo=github)](https://qcbsrworkshops.github.io/workshop06/book-fr/index.html)
[![badge](https://img.shields.io/static/v1?style=flat-square&label=wiki&message=07&logo=wikipedia)](https://wiki.qcbs.ca/r_atelier6)
![badge](https://img.shields.io/static/v1?style=flat-square&label=script&message=07&color=2a50b8&logo=r)
[![badge](https://img.shields.io/static/v1?style=flat-square&label=repo&message=dev&color=6f42c1&logo=github)](https://github.com/QCBSRworkshops/workshop06) 

---

# Packages requis

* [ggplot2](https://cran.r-project.org/package=ggplot2)
* [lme4](https://cran.r-project.org/package=lme4)
* [MASS](https://cran.r-project.org/package=MASS)
* [vcdExtra](https://cran.r-project.org/package=vcdExtra)
* [bbmle](https://cran.r-project.org/package=bbmle)
* [DescTools](https://cran.r-project.org/package=DescTools)

<br>

```R
install.packages(c('ggplot2', 'lme4', 'MASS', 'vcdExtra', 'bbmle', 'DescTools'))
```

---

# Objectifs d'apprentissage
<br>

##### 1. Pourquoi √™tre normal?
##### 2. GLM avec variable binaire
##### 3. GLM avec des donn√©es d'abondance

---
class: inverse, center, middle

# Pourquoi √™tre normal?

<hr>

### Y aurait-il un meilleur mod√®le?


---
# Limitations des mod√®les lin√©aires (mixtes)

Charger les donn√©es et appliquer un mod√®le lin√©aire (`lm()`) :

```{r,echo=FALSE}
mites <- read.csv('data/mites.csv')
```

```{r,eval=F}
# v√©rifiez que vous √™tes dans le bon r√©pertoire de travail
mites <- read.csv('data/mites.csv')
head(mites)
str(mites)
```

Le jeu de donn√©es charg√© contient une partie du jeu de donn√©es classique des
[mites Oribatid (Acari,
Oribatei)](http://adn.biol.umontreal.ca/~numericalecology/data/oribates.html)
des sphaignes (Sphagnum sp.) du Lac Geai, [Station de Biologie de l'Universit√©
de Montreal](https://goo.gl/maps/PxN1Q7KUPnUt92Eu5) :

.small[
> 70 √©chantillons de mousses et mites

> 5 variables environmentales, abondance de la mite *Galumna sp.*, et abondance totale des mites
]

--

.alert[Objectif]: Mod√©liser l'abondance (`abund`), l'occurrence (`pa`), et la proportion (`prop`) de Galumna en fonction des 5 param√®tres environnementaux.



---
# Explorer les relations

Pouvons-nous voir une/des relation(s) entre *Galumna* et les 5 variables environnementales?

--

.pull-left2[
```{r,echo = -1}
par(mypar)
plot(mites)
```
]
.pull-right2[
<br><br><br><br>
`Galumna` vs `WatrCont`?!
]


---
# Explorer les relations

Une relation negative entre `Galumna` et le contenu en eau du sol?

```{r,fig.width=12,fig.height=4.5,echo=-1}
par(mypar)
par(mfrow = c(1, 3), cex = 1.4)
plot(Galumna ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Abondance')
boxplot(WatrCont ~ pa, data = mites, xlab='Pr√©sence/Absence', ylab = 'Contenu en eau')
plot(prop ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Proportion')
```

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

--
```{r, eval = -c(2, 4, 6)}
lm.abund <- lm(Galumna ~ WatrCont, data = mites)
summary(lm.abund)
lm.pa <- lm(pa ~ WatrCont, data = mites)
summary(lm.pa)
lm.prop <- lm(prop ~ WatrCont, data = mites)
summary(lm.prop)
```

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

.pull-left[
```{r}
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
```
]
.pull-right[
Un effet significatif dans tous les mod√®les!

.alert[Mais...]
]

---
# Tester la lin√©arit√©

Un effet significatif dans tous les mod√®les! .alert[Attends une minute...]

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(Galumna ~ WatrCont, data = mites)
abline(lm.abund)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.abund)
```
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Proportion `prop`) :

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(prop ~ WatrCont, data = mites)
abline(lm.prop)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.prop)
```
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Pr√©sence/Absence `pa`) :

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(pa ~ WatrCont, data = mites)
abline(lm.pa)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.pa)
```
]

---
# Conditions d'application du mod√®le lin√©aire

<br>

Il est **tr√®s commun** en √©cologie que les conditions d'application du mod√®le
lin√©aire ne soient pas respect√©es. C'est pourquoi nous avons souvent besoin des
**mod√®les lin√©aires g√©n√©ralis√©es** (GLMs).

<br>

.alert[Rafra√Æchissons-nous la m√©moire √† propos des conditions d'application du mod√®le lin√©aire.]

---
# Conditions d'application du mod√®le lin√©aire

√âquation du mod√®le:

$$y_i = \beta_0 + \beta_1x_i + \varepsilon_i$$

o√π:

- $y_i$ = valeur estim√©e pour la i<sup>√®me</sup> variable r√©ponse,
- $\beta_0$ = ordonn√©e √† l'origine de la droite,
- $\beta_1$ = pente,
- $x_i$ = i<sup>√®me</sup> valeur de la variable observ√©e.
- $\varepsilon_i$ = r√©sidus du mod√®le obtenus d'une distribution normale de moyenne 0 et de variance constante (qui est √† estimer).


---
# Distribution normale
<br>

Une autre mani√®re d'√©crire le mod√®le lin√©aire est :

$$Y_i \sim \mathcal{N}(\mu = \beta_0 + \beta_1x_i, \sigma^2)$$

<br>
Ce qui signifie que $y_i$ (r√©alisation de la variable al√©atoire $Y_i$) est √©chantillonn√©e dans une distribution normale ayant les param√®tres $\mu$ (dont la valeur d√©pend de $x_i$) et $\sigma$ (ind√©pendantes de $x_i$)

<br>
Essayons de pr√©dire l'abondance de `Galumna` en fonction du contenu d'eau en utilisant `lm()` que nous avons vu plus t√¥t.

---
# Distribution normale

**Rappel** : La distribution normale a deux param√®tres, $\mu$ (moyenne) et $\sigma$ (variance)

<br>
.pull-left[
3 valeurs pour $\mu$, $\sigma = 5$

```{r, echo=FALSE}
x = seq(1, 50, 0.1)
par(mypar);par(cex = 1.4)
plot(x, dnorm(x, mean = 20, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©')
points(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 30, sd = 5), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('20', '25', '30'), lty = 1, col = c(1, 2, 4), bty = 'n', lwd = 2, cex = 1.1)
```
]
.pull-right[
$\mu = 25$, 3 valeurs pour $\sigma$

```{r, echo=FALSE}
par(mypar);par(cex = 1.4)
x = seq(1, 50, 0.1)
plot(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©')
points(x, dnorm(x, mean = 25, sd = 7.5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 25, sd = 10), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('5', '7.5', '10'), lty = 1, col = c(1, 2, 4), bty = 'n', lwd = 2, cex = 1.1)
```
]




---
# Distribution normales des r√©sidus

.large[.alert[Pour utiliser correctement le mod√®le lin√©aire, il faut s'assurer que les r√©sidus sont distribu√©s selon une loi normale centr√©e.]]

<br>

Il faut donc **v√©rifier la normalit√© des r√©sidus** et non celle la distribution de la variable de r√©ponse, comme le Andrew MacDonald dans un tweet √† propos de cette derni√®re pratique:

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This is the wrong thing to do because what matters is how your &quot;response variable&quot; is distributed *AFTER* you do your model, not before! <a href="https://twitter.com/rlmcelreath?ref_src=twsrc%5Etfw">@rlmcelreath</a> called this practice &quot;histomancy&quot;, which name I love</p>&mdash; Andrew MacDonald üåà (@polesasunder) <a href="https://twitter.com/polesasunder/status/1225100358738948101?ref_src=twsrc%5Etfw">February 5, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>



---
# Pr√©diction du mod√®le
<br>

Nous avons besoin des coefficients de r√©gression ( $\beta_0$ et $\beta_1$) et de $\sigma$ :

```{r}
coef(lm.abund)
summary(lm.abund)$sigma
```

Quels sont les param√®tres de la distribution normale utilis√©s pour mod√©liser $y$ lorsque le contenu d'eau = 300?

$$y_i \sim N(\mu = \beta_0 + \beta_1 x_i, \sigma^2)$$

--

$\mu = 3.44 + (-0.006 x 300) = 1.63$

$\sigma = 1.51$

---
# Pr√©diction du mod√®le

- Lorsque $x_i = 300$, $Y_i$ suit une distribution normale avec $\mu = 1.63$ et $\sigma^2 = 1.51$.

- Lorsque $x_i = 400$, $Y_i$ suit une distribution normale avec $\mu = 1.02$ et $\sigma^2 = 1.51$, etc.


<br>
Graphiquement, notre mod√®le ressemble √† :

--
.pull-left[
.center[
  ![:scale 100%](images/modelPredic.png)
]]

--
.pull-right[

**Quelles sont les probl√®mes avec ce mod√®le?**

1. La pente ne suit pas les observations
2. Les $\mu$ (moyennes) sont incorrectes
3. Les $\sigma^2$ (variances) sont consider√©s homog√®nes
4. Le distribution normal est continu mais les observations sont disc√®tes
]

---
# Pr√©diction du mod√®le

- Lorsque $x_i = 300$, $Y_i$ suit une distribution normale avec $\mu = 1.63$ et $\sigma^2 = 1.51$.

- Lorsque $x_i = 400$, $Y_i$ suit une distribution normale avec $\mu = 1.02$ et $\sigma^2 = 1.51$, etc.


<br>
Graphiquement, notre mod√®le ressemble √† :

--
.pull-left[
.center[
  ![:scale 100%](images/modelPredic.png)
]]

--
.pull-right[

**Probl√®mes**:
- $\sigma^2$ n'est pas homog√®ne, mais `lm()` nous contraint d'utiliser toujours la m√™me valeur de $\sigma^2$,
- Les valeurs estim√©es devraient √™tre des nombres entiers.
]

---
# Donn√©es biologiques & distributions

<br>

- Les statisticiens ont d√©velopp√© [de nombreuses lois de probabilit√© (distributions)](https://www.causascientia.org/math_stat/Dists/Compendium.pdf) correspondant √† divers types de donn√©es

- Une distribution donne la probabilit√© d'observer chaque issue possible d'une exp√©rience ou √©chantillonage (e.g. $abund = 8$ Galumna)

- Les distributions peuvent √™tre **discr√®tes** (que des nombres entiers) ou **continues** (incluent aussi des fractions)

- Toutes les distributions ont des **param√®tres** qui d√©terminent leur forme (e.g. $\mu$ et $\sigma^2$ pour la distribution normale)

---
# Donn√©es biologiques & distributions

L'abondance de *Galumna* suit une distribution discr√®te (que des nombres entiers). Pour mod√©liser les donn√©es d'abondance, la [loi de Poisson](https://fr.wikipedia.org/wiki/Loi_de_Poisson) est souvent utilis√©e:

- une distribution discr√®te avec un seul param√®tre, $\lambda$ (lambda), qui d√©termine la moyenne et la variance de la distribution:

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dpois(x, lambda = 1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 1')
plot(x, dpois(x, lambda = 10), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 10')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 30')
```

---
# Donn√©es biologiques & distributions

*Galumna* semble suivre une loi de Poisson avec une faible valeur de $\lambda$ :

```{r}
  mean(mites$Galumna)
  hist(mites$Galumna)
```

---
# Donn√©es biologiques & distributions

Pr√©sence-absence par contre prend une autre forme :

- Inclut seulement des `0`s et des `1`s
- La loi de Poisson n'est pas appropri√©e pour cette variable

```{r, fig.height=4, echo=-1}
  par(mypar);par(cex=1.4)
  hist(mites$pa)
```

---
# Donn√©es biologiques & distributions

**Distribution de [Bernoulli](https://fr.wikipedia.org/wiki/Loi_de_Bernoulli)** :

- N'inclut que deux issues possibles dans son ensemble: succ√®s (`1`) ou √©chec (`0`)
- N'a qu'un param√®tre, $p$, la probabilit√© de succ√®s

<br>
```{r,echo=-F,fig.width=12,fig.height=4}
  par(mypar);par(mfrow = c(1, 3), cex=1.4)
  barplot(setNames(c(.9, .1), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.1')
  barplot(setNames(c(.5, .5), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.5')
  barplot(setNames(c(.1, .9), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.9')
```
Nous pouvons utiliser la loi de Bernoulli pour calculer la probabilit√© d'obtenir l'issue "Galumna present" (`1`) vs. "Galumna absent" (`0`)

---
# Donn√©es biologiques & distributions

**[Distribution binomiale](https://fr.wikipedia.org/wiki/Loi_binomiale)** : Lorsqu'il y a plusieurs √©preuves (chacune avec un succ√®s/√©chec), la loi de Bernoulli se transforme en loi binomiale

- Inclut le param√®tre additionel $n$, le nombre d'√©preuves
- Pr√©dit la probabilit√© d'observer une certaine proportion de succ√®s, $p$, sur le nombre total d'√©preuves, $n$

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.1 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.5), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.5 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.9 n = 50')
```

---
# Donn√©es biologiques & distributions

**Distribution binomiale** : utilis√©e pour mod√©liser des donn√©es lorsque le nombre de succ√®s est donn√© par un nombre entier, et lorsque le nombre d'√©preuves, $n$, est connu.

**Diff√©rence principale avec la loi de Poisson** : L'√©tendue de la loi binomiale a une limite sup√©rieure, $n$. Par cons√©quent, elle est asym√©trique et d√©cal√©e √† gauche lorsque $p$ est faible, mais d√©cal√©e √† droite lorsque $p$ est √©lev√©.

```{r,echo=F,fig.width=10, fig.height=4}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 2), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.9 n = 50')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 30')
```

---
# Donn√©es biologiques & distributions

Retournons √† notre probl√®me pour changer la distribution de $Y_i$ de normale √† Poisson :

$$Y_i \sim Poisson(\lambda = \beta_0 + \beta_1 x_i)$$

Le probl√®me est r√©solu!

1. $\lambda$ varie avec $x$ (contenu d'eau) et la variance des r√©sidus changera aussi avec $x$, et nous venons de nous d√©faire de la supposition d'homog√©n√©it√© de la variance!

2. Les valeurs estim√©es seront des nombres entiers plut√¥t que des nombres d√©cimaux;

3. Ce mod√®le ne pr√©dira jamais de valeurs n√©gatives (Poisson est toujours strictement positif).

---
# Donn√©es biologiques & distributions

Ce mod√®le est **presque** un GLM de Poisson, qui ressemble √† √ßa:

.center[![:scale 90%](images/poisPred.png)]

Les probabilit√©s (en orange) sont maintenant des nombres entiers, et la variance et la moyenne de la distribution d√©clinent lorsque $\lambda$ diminue avec le contenu d'eau.

---
class: inverse, center, middle

# GLM avec variable binaire

<hr>

---
# Variables binaires
<br>

Une variable r√©ponse commune dans les jeux de donn√©es en √©cologie : variable binaire, on observe un ph√©nom√®ne X ou son "absence"

- Pr√©sence/Absence d'une esp√®ce
- Pr√©sence/Absence d'une maladie
- Succ√®s/√âchec d'observer un comportement
- Survie/Mort d'un organisme

On veut d√©terminer si $P/A \sim Environment$

.comment[R√©gression logistique ou mod√®le logit]

---
# Variables binaires

Dans `R`, on code une variable binaire avec `1` et `0`:

```{r,echo=F}
Site <- LETTERS[1:6]
Presence <- c(1, 0, 1, 1, 0, 1)
dat = data.frame(Site, Presence)
```

<br>

.pull-left[
.right[
```{r, echo=F}
print(dat)
```
]]
.pull-right[
 <br>

 1 = Pr√©sence

 <br>

 0 = Absence
]

---
exclude: true

# Variables binaires


```{r,echo=F,fig.width=7, fig.height=6}
par(mypar);par(cex = 1.4)
hist(Presence)
```

.alert[Avec un mod√®le lin√©aires, les r√©sidus ne seront pas distribu√©s normalement!]

---
# Variables binaires

Les valeurs pr√©dites peuvent se trouver hors de l'intervalle `[0,1]` avec `lm()`:

<br>

```{r,echo=F,fig.width=7.5, fig.height=5.6}
Pres <- c(rep(1, 40), rep(0, 40))
rnor <- function(x) rnorm(1, mean = ifelse(x == 1, 12.5, 7.5), sd = 2)
ExpVar <- sapply(Pres, rnor)
par(mypar);par(cex = 1.4)
plot(ExpVar, Pres, ylim = c(-.5, 1.5), xlab = 'Variable explicative', ylab = 'Pr√©sence', main = "Valeurs pr√©dites d'un lm() avec une variable binaire", pch = 16)
abline(lm(Pres ~ ExpVar), col = 'orange', lwd = 2)
mtext(expression(symbol("\255")), at = 1.25, side = 4, line = 0.1, cex = 6, col = 'blue')
mtext(expression(symbol("\256")), at = 3, side = 1, line = -2.2, cex = 6, col = 'blue')
```

---
exclude: true

# Distribution de probabilit√©

La distribution de Bernoulli est adapt√©e pour des variables r√©ponses binaires

<br>

.pull-left[.right[

$E(Y) = p$

<br>

$Var(Y) = p \times (1 - p)$

]]
.pull-right[

![:faic](arrow-right) **Moyenne de la distribution** .small[Probabilit√© $p$ d'observer un r√©sultat]

![:faic](arrow-right) **Variance de la distribution** .small[La variance d√©cro√Æt quand $p$ est proche de `0` ou `1`]
]

---
# R√©gression logistique

La fonction `glm()`!

<br>

```R
logit.reg <- glm(formula, data, family)
```

<br>

Pour utiliser la bonne distribution, il faut sp√©cifier:

1. distribution de probabilit√©

--
**ET**

--
2. une [fonction de lien](https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function) (il y a une fonction de lien par d√©faut pour une distribution donn√©e!) qui d√©finit aussi une relation entre la moyenne et la variance.

<br>

--

Dans R, cela se fait en utilisant l'argument `family` (voir `?family`) :

---
# La fonction de lien

Pour un mod√®le lin√©aire de base d'une variable r√©ponse normalement distribu√©e, l'√©quation pour la valeur attendue est :

$$\mu = x\beta$$

o√π

- $\mu$ repr√©sente les valeurs pr√©dites par le mod√®le,
- $x$ est la matrice du mod√®le (*i.e.* les variables explicatives),
- $\beta$ est le vecteur des param√®tres estim√©s (*i.e.* intercept & pente).


###### $x\beta$ est appel√© le **pr√©dicteur lin√©aire**

---
# La fonction de lien

$\mu = x\beta$ est vrai seulement pour la distribution normale

Si ce n'est pas le cas, on utilise une transformation $g$ sur $\mu$

$$g(\mu) = x\beta$$

o√π $g$ est appel√©e **fonction de lien**. Cela permet de travailler avec des distributions autres que la loi normale.

---
# La fonction de lien

Pour les donn√©es binaires, on utilise la transformation **logit** :

<br>

$$g(\mu) = log\left(\frac{\mu}{1-\mu}\right)$$

$\mu =$ variables pr√©dites (probabilit√© que $Y = 1$)

--

1. $\frac{\mu}{1-\mu}$ met les valeurs pr√©dites sur une √©chelle de  `0` √† `+Inf`
2. La transformer en log ce qui projette les valeurs pr√©dites sur entre`-Inf` √† `+Inf`

--

<br>

![:faic](arrow-right) Les valeurs pr√©dites **transform√©es** sont reli√©es **lin√©airement** au pr√©dicteur lin√©aire

---
# Exercice 1

Sp√©cifiez un mod√®le de r√©gression logistique avec le jeu de donn√©es mites.

```{r,eval=F}
#setwd('...')
mites <- read.csv("mites.csv", header = TRUE)
str(mites)

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
str(mites)
```

---
# Exercice 1

Sp√©cifiez un mod√®le de la pr√©sence et de l'absence de *Galumna sp.* en fonction du contenu en eau du sol et de la topographie.

```{r}
logit.reg <- glm(pa ~ WatrCont + Topo, data=mites,
family = binomial(link = "logit"))
```
```{r,eval=F}
summary(logit.reg)
```

---
# Exercice 1

.small[
```{r}
summary(logit.reg)
```
]

---
# D√©fi 1 ![:cube]()

En utilisant le jeu de donn√©es 'bacteria', sp√©cifiez un mod√®le de la pr√©sence de *H. influenzae* en fonction du traitement et de la semaine de test.

Commencez avec un mod√®le satur√© et trouvez le mod√®le le plus parcimonieux.


```{r}
#install.packages("MASS")
library(MASS)
data(bacteria)
str(bacteria)
```

???

Ceci est un exercise de groupe. Les groupes sont de 3-4 personnes et le duree est de 5 minutes.

---
# Solution ![:cube]()

```{r}
model.bact1 <- glm(y ~ trt * week, data = bacteria, family = binomial)
```

```{r}
model.bact2 <- glm(y ~ trt + week, data = bacteria, family = binomial)
```

```{r}
model.bact3 <- glm(y ~ week, data = bacteria, family = binomial)
```

```{r}
anova(model.bact1, model.bact2, model.bact3, test = "LRT")
```

---
# Interpr√©ter la sortie

Regardez √† nouveau les coefficients du mod√®le `logit.reg` :

```{r}
summary(logit.reg)$coefficients
```

La sortie indique que le contenu d'eau et la topographie sont significatifs

.comment[Mais comment interpr√®te-on les coefficients de la pente?]

---
# Interpr√©ter la sortie

Rappelez-vous que nous avons utilis√© une transformation logit!

Pour bien interpr√©ter les coefficients du mod√®le, il faut les utiliser avec la fonction de lien inverse ( $g^{-1}$ ):

$$g^{-1}(\beta_0 + \beta_1x)$$


<!-- La fonction exponentielle pour obtenir les cotes : $e^x$ -->

Dans notre exemple, la fonction $logit$ inverse est utiliser pour obtenir les probabilit√©s :

$$logit^{-1} = \frac{1}{1 + e^{-(\beta_0 + \beta_1 WatrCont + \beta_2 TopoHummock)}}$$


---
# Pouvoir pr√©dictif et ajustement du mod√®le
<br>

Le [pseudo-R¬≤](https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/), un concept analogue au $R^2$ pour les mod√®les estim√©s par maximisation de la vraisemblance:

$$\text{pseudo-R}^2 = \frac{\text{d√©viance nulle - d√©viance r√©siduelle}}{\text{d√©viance nulle}}$$

<br>

$\text{pseudo-R}^2 = \text{variance expliqu√©e par le mod√®le}$

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Comparer la d√©viance du mod√®le (d√©viance r√©siduelle) √† la d√©viance d'un mod√®le nul (d√©viance nulle)

Le **mod√®le nul** est un mod√®le sans variables explicatives, simplement l'ordonn√©e √† l'origine

```R
null.model <- glm(Response.variable ~ 1, family = binomial)
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :

```{r}
objects(logit.reg)
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

En utilisant les d√©viances de l'objet `logit.reg` c'est quoi le valeur du pseudo `R^2`?

???

Instruire aux participants de r√©pondre au question dans l'appel Zoom au coordinateur(e)
---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :

```{r}
pseudoR2 <- (logit.reg$null.deviance - logit.reg$deviance) / logit.reg$null.deviance
pseudoR2
```

.comment[Ainsi, le mod√®le explique 46.6% de la variabilit√© des donn√©es]

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Nouvelle statistique - **coefficient de discrimination (D)** √©value le pouvoir pr√©dictif d'une r√©gression logistique

- Mesure √† quel point la r√©gression logistique est capable de bien classifier un r√©sultat en succ√®s ou √©chec

Pour √©valuer l'ajustement du mod√®le, les graphiques de diagnostique ne sont pas utiles, il vaut mieux utiliser le [test de Hosmer-Lemeshow](https://en.wikipedia.org/wiki/Hosmer%E2%80%93Lemeshow_test):

- Compare le nombre de r√©sultats obtenus et attendus
- Similaire √† un test de $Chi^2$

---
# Exercice 2

La fonction R `PseudoR2` dans le package` DescTools` permet de calculer plusieurs Pseudo R2. En sp√©cifiant `which = all`, calculez toutes les statistiques en m√™me temps.


```{r, echo = -1}
logit.reg <- glm(mites$pa ~ mites$WatrCont + mites$Topo, family = binomial(link = "logit")) # needed for the rmd presentation, or else problem with PseudoR2 environment...
library(DescTools)
fit <- PseudoR2(logit.reg, which = "all")
fit
```

---
exclude: true

# Exercice 2: Faites le test de Hosmer-Lemeshow

```{r}
library(vcdExtra)
HLtest(logit.reg)
```

.comment[Une valeur non significative indique un ajustement ad√©quat!]

---
# D√©fi 2 ![:cube]()
<br>


1. En utilisant le mod√®le cr√©√© avec le jeu de donn√©es 'bacteria', √©valuez le pouvoir pr√©dictif et l'ajustement de ce mod√®le.

2. Comment faire pour am√©liorer le pouvoir explicatif du mod√®le?

???

Cette exercise est fait dans un breakout room avec des groupes de 3-4 pour un dur√©e de 5 minutes

---
# Solution ![:cube]()

1 :
```{r,eval=F}
null.d <- model.bact2$null.deviance
resid.d <- model.bact2$deviance
bact.pseudoR2 <- (null.d - resid.d) / null.d
HLtest(model.bact2)
```

2 : Ajouter des variables explicatives pertinentes pourrait certainement augmenter le pouvoir explicatif du mod√®le.

---
# GLM et donn√©es de proportions

Parfois, les donn√©es de proportions sont plus similaires √† un r√©gression logistique que ce que vous pensez...

Si on mesure un nombre d'occurences et qu'on conna√Æt la taille d'√©chantillon, on obtient des donn√©es de proportions!

Supposons qu'on mesure la pr√©valence d'une maladie sur dix cerfs dans 10 populations diff√©rentes :

.pull-left[

$$\frac{x\,\, \text{infected deer}}{10\,\,\text{deer}}$$

]

.pull-right[
![:faic](arrow-right) toujours entre `0` et `1`!
]

---
# GLM et donn√©es de proportions

Les proportions peuvent √™tre cod√©s en fournissant le nombre de succ√®s et d'√©chec
```{r}
prop.reg <- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial)
```

On peut aussi coder les proportions directement
```{r}
prop.reg2 <- glm(prop ~ Topo + WatrCont, data = mites,
                 family = binomial, weights = totalabund)
```

---
exclude: true

# Exercice 3

Dans R, on doit sp√©cifier le nombre de fois qu'un √©v√©nement s'est produit et le nombre de fois qu'un √©v√©nement ne s'est pas produit:

```{r}
prop.reg <- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial)
```

```r
summary(prop.reg)
```

---
exclude: true

# Exercice 3

.small[
```{r}
summary(prop.reg)
```
]

---
exclude: true

# Exercice 3

On peut coder le mod√®le directement avec les proportions:

```{r}
prop.reg2 <- glm(prop ~ Topo + WatrCont, data = mites,
                 family = binomial, weights = totalabund)
```

---
class: inverse, center, middle

# GLM avec des donn√©es d'abondance

<hr>

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Importez le jeu de donn√©es `faramea.csv` dans R

```{r,echo=F}
faramea <- read.csv('data/faramea.csv', header = TRUE)
```
```{r,eval=F}
faramea <- read.csv('faramea.csv', header = TRUE)
```

Le nombre d'arbres de l'esp√®ce *Faramea occidentalis* a √©t√© compt√© dans 43 quadrats sur l'√Æle de Barro Colorado (Panama). Des donn√©es environnementales, comme l'√©l√©vation et la pr√©cipitation ont aussi √©t√© mesur√©es.

Examinons maintenant √† quoi ressemble la distribution du nombre d'arbres par transect.

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

```{r, echo=F,fig.height=5}
par(mypar);par(cex = 1.4)
hist(faramea$Faramea.occidentalis, breaks = 30, col = 'gray', xlab = 'Nombre de F. occidentalis', ylab = 'Fr√©quence', main = '')
```

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Les donn√©es d'abondance sont charact√©ris√©es par:

- des valeurs positives : on ne peut pas compter -7 individus
- des valeurs enti√®res : on ne peut pas compter 7.56 individus
- une plus grande variance pour les fortes valeurs

---
# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

```{r, echo=F,fig.height=5}
par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Nombre de F. occidentalis', xlab = '√âlevation(m)')
```

---
# Mod√©liser des donn√©es d'abondance

```{r, echo=F,fig.height=5}
par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Nombre de F. occidentalis', xlab = '√âlevation(m)')
```

Quelle distribution mod√®le le mieux ces observations√â
1. Bernoulli
2. Normale
3. Poisson
4. Binomial

???

Ceci est un question √† un choix.
---

# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

La **distribution de Poisson** semble √™tre le choix parfait pour mod√©liser ces donn√©es, ainsi des **GLMs Poisson** sont g√©n√©ralement une bonne fa√ßon pour commencer √† mod√©liser des donnes d'abondance.

---
# La distribution de Poisson

La distribution de poisson, qui sp√©cifie la probabilit√© d'une variable al√©atoire discr√®te Y, est donn√©es par :

$$f(y, \,\mu)\, =\, Pr(Y = y)\, =\, \frac{\mu^y \times e^{-\mu}}{y!}$$

$$E(Y)\, =\, Var(Y)\, =\, \mu$$

**Propri√©t√©s** :

- $\mu$ est le param√®tre de la distribution de Poisson
- sp√©cifie la probabilit√© pour des valeurs enti√®res uniquement
- la probabilit√© pour des valeurs n√©gatives est nulle ( $P(Y<0) = 0$)
- moyenne = variance (permet l'h√©t√©rog√©n√©it√©)

---
# Que se cache-t-il derri√®re un GLM Poisson?

Un GLM Poisson va mod√©liser la valeur de $\mu$ en fonction de diff√©rentes variables explicatives.

.center[**Trois √©tapes**]

**√âtape 1.** On suppose que $Y_i$ suit une distribution de Poisson de moyenne et variance $\mu_i$

$$Y_i = Poisson(\mu_i)$$

$$E(Y_i) = Var(Y_i) = \mu_i$$

$$f(y_i, \, \mu_i) = \frac{\mu^{y_i}_i \times e^{-\mu_i}}{y!}$$

$\mu_i$ correspond au nombre attendu d'individus

---
# Que se cache-t-il derri√®re un GLM Poisson?

**√âtape 2.** On sp√©cifie le pr√©dicteur lin√©aire comme dans un mod√®le lin√©aire

$$\underbrace{\alpha}_\text{One intercept} + \underbrace{\beta}_\text{slope of 'Elevation'} \times \text{Elevation}_i$$

**√âtape 3.** La fonction de lien entre la moyenne de $Y_i$ et la partie syst√©matique est un log

$$log(\mu_i) = \alpha + \beta \times \text{Elevation}_i$$

.center[ou]

$$\mu_i = e^{ \alpha + \beta \times \text{Elevation}_i}$$

---
# Ajuster un GLM Poisson sous R

La fonction `glm()` permet de sp√©cifier un GLM Poisson

```{r}
glm.poisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=poisson)
```

L'argument `family` permet de sp√©cifier le type de distribution et la fonction de lien (log)

<br>

Tout comme avec `lm()`, vous pouvez acc√©der au r√©sum√© du mod√®le √† l'aide de la fonction `summary()`

```{r,eval=F}
summary(glm.poisson)
```

---
# R√©sum√© du mod√®le

.pull-left2[
.small[
```{r}
summary(glm.poisson)
```
]]

.pull-right2[
Estim√©s :

Intercept = $\alpha$

√âlevation = $\beta$

]

--

.pull-right2[
<br>
Qu'en est-il de `Null deviance` et `Residual deviance`?!
]

???

Mentionner que la d√©viance r√©siduelle de 388.12 est beaucoup plus √©lev√©e que les degr√©s de libert√© r√©siduels de 41 ce qui indique le surdispersion

---
exclude: true

# Estimation des param√®tres

Dans notre mod√®le, les param√®tres √† estimer sont l'ordonn√©e √† l'origine ( $\alpha$ ) et le coefficient de r√©gression de l'√©levation ( $\beta$ )


$$log(\mu_i) = 1.769 - 0.0027 \times \text{√âlevation}_i$$

.center[ou]

$$\mu_i = e^{1.769 - 0.0027 \times \text{√âlevation}_i}$$


---
exclude: true

# La d√©viance

Rappelez vous que pour estimer les param√®tres inconnus, l'estimation par maximum de vraisemblance est utilis√©e

La d√©viance r√©siduelle est approximativement la diff√©rence entre la vraisemblance d'un mod√®le satur√© (n param√®tres pour chaque observation) et le mod√®le complet (p param√®tres):

$$\text{Res dev} = 2 \, log(L(y;\,y)) - 2 \, log(L(y;\, \mu))$$

Dans un GLM Poisson, la d√©viance r√©siduelle doit √™tre √©gale au nombre de degr√©s de libert√© r√©siduels

.center[.alert[388.12 >> 41]]

---
# La surdispersion

Quand la d√©viance r√©siduelle est sup√©rieure au nombre de degr√©s de libert√© r√©siduels, le mod√®le est **surdispers√©**

$$\phi ~ = ~\frac{\text{D√©viance r√©siduelle}}{\text{Degr√©s de libert√© r√©siduels}}$$

Se produit lorsque la variance dans les donn√©es est plus grande que la moyenne. Dans ce cas la distribution de Poisson n'est plus appropri√©e (beaucoup de z√©ros, covariables manquantes, etc.)

.center[.large[**Solutions**]]

.pull-left[
1: Corriger la surdispersion en utilisant en **GLM quasi-Poisson**
]

.pull-right[
2: Choisir une autre distribution : **la [negative binomial](https://fr.wikipedia.org/wiki/Loi_binomiale_n%C3%A9gative)**
]

---
# GLM Quasi-Poisson

La variance du mod√®le tient compte de la **surdispersion** en ajoutant le param√®tre de surdispersion:

$$E(Y_i) = \mu_i$$

$$Var(Y_I) = \phi \times \mu_i$$

le **pr√©dicteur lin√©aire** et la **fonction de lien** restent les m√™me

$\phi$ est le param√®tre de dispersion. Il sera estim√© avant les param√®tres. Corriger pour la surdispersion ne va pas affecter l'estimation des param√®tres, mais leur **significativit√©**. En effet, les √©carts-types des param√®tres seront multipli√©s par $\sqrt{\phi}$.

.alert[Certaines p-values marginalement significatives peuvent devenir non significatives!]

---
exclude: true

# Ajuster un GLM quasi-Poisson sous R

Cr√©ez un nouveau GLM √† l'aide de la famille 'quasipoisson' ou actualisez le mod√®le pr√©c√©dent:

```{r}
glm.quasipoisson = glm(Faramea.occidentalis ~ Elevation, data = faramea,
                       family=quasipoisson)
glm.quasipoisson = update(glm.poisson, family = quasipoisson)
```

---
exclude: true

# Ajuster un GLM quasi-Poisson sous R

.pull-left2[
.small[
```{r}
summary(glm.quasipoisson)
```
]]
.pull-right2[
**M√™mes estim√©s mais**

.small[Les √©carts-types des param√®tres sont multipli√©s par]

$$\sqrt{\phi} = 4$$

`0.0006436 * 4 = 0.00257`

<- $\phi$

<br>

<- .small[Pas d'AIC!]
]

---
exclude: true

# Ajuster un GLM quasi-Poisson sous R

Testons l'effet de l'√©l√©vation par une analyse de d√©viance :

```{r}
null.model <- glm(Faramea.occidentalis ~ 1, data = faramea,
                  family = quasipoisson)
anova(null.model, glm.quasipoisson, test = "Chisq")
```

---
# Param√®tre de dispersion

.center[![:scale 80%](images/dispParam.png)]

---
# GLM binomiale n√©gative

Une distribution binomiale n√©gative est favoris√©e quand la surdispersion est forte

- La distribution a **deux param√®tres** $\mu$ and $k$. $k$ contr√¥le pour la dispersion (plus la dispersion est forte, plus $k$ est petit)
- C'est une combinaison de deux distributions (**Poisson** et **gamma**)
- Les $Y_i$ suivent une distribution de Poisson dont la moyenne $\mu$ suit une distribution Gamma!

$$E(Y_i) = \mu_i$$

$$Var(Y_i) = \mu_i + \frac{\mu^2_i}{k}$$


---
# Ajuster une binomiale n√©gative sous R

NB La distribution binomiale n'est pas dans la fonction `glm()` donc il faut installer et charger la paquet `MASS`

```r
install.packages('MASS')
```

```{r}
glm.negbin = glm.nb(Faramea.occidentalis ~ Elevation, data = faramea)
```

```r
summary(glm.negbin)
```

---
# Ajuster une binomiale n√©gative sous R

.pull-left2[
.small[
```{r,echo=-1}
summary(glm.negbin)
```
]]
.pull-right2[

<br><br><br><br><br><br><br><br><br><br><br><br><br>
`theta` $= k$
]

---
# Repr√©senter le mod√®le final

**√âtape 1** Repr√©senter les donn√©es et utiliser les estimations des param√®tres pour repr√©senter le mod√®le

$$\mu_i = e^{2.369 - 0.007 \times Elevation_i}$$

Utilisez `summary()` pour obtenir les param√®tres

```r
summary(glm.negbin)$coefficients[1, 1]
summary(glm.negbin)$coefficients[2, 1]
```

---
# Repr√©senter le mod√®le final

**√âtape 2** Utilisez les √©carts-types pour construire l'intervalle de confiance

```r
summary(glm.negbin)$coefficients[1, 2]
summary(glm.negbin)$coefficients[2, 2]
```

$$\text{Limite sup} = e^{[\alpha - 1.96 \times SE_{\alpha}] + [\beta - 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$

$$\text{Limit inf} = e^{[\alpha + 1.96 \times SE_{\alpha}] + [\beta + 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$

---
# Repr√©senter le mod√®le final

.small[
```{r,eval=F}
pp <- predict(glm.negbin, newdata = data.frame(Elevation = 1:800), se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function
pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
sc <- abs(qnorm((1-0.95)/2))  ## Normal approx. to likelihood
pframe <- transform(pframe, lwr = linkinv(pred0-sc*pp$se.fit), upr = linkinv(pred0+sc*pp$se.fit))
# sinon, utiiser predic() avec type="response"

plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]

```{r,echo=F, fig.height=4}
pframe <- data.frame(Elevation = 1:800)
pp <- predict(glm.negbin, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis,
      ylab = 'Nombre de F. occidentalis', xlab = '√âlevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```

---
# D√©fi 3 ![:cube]()


Utilisez le jeu de donn√©es `mites`! Mod√©lisez l'abondance de l'esp√®ce *Galumna* en fonction des caract√©ristiques du substrat (son contenu en eau `WatrCont` et sa densit√© `SubsDens`)

- Faut-il contr√¥ler pour la surdispersion?
- Quelles variables explicatives ont un effet significatif?
- Selectionnez le meilleur mod√®le!

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
```
```{r,eval=F}
mites <- read.csv("mites.csv", header = TRUE)
```

???

Cette exercies est fait en breakout room avec des equipes de 3-4 pour une duree de 10 minutes

---
# D√©fi 3 : conseils ![:cube]()

S√©lection pas √† pas en retirant √† chaque fois une variable et en comparant le mod√®le emboit√© au mod√®le complet :

```r
drop1(MyGLM, test = "Chi")
```

Sp√©cifiez un mod√®le embo√Æt√© manuellement, appelez le `MyGLM2`, et utilisez la fonction anova():

```r
anova(MyGLM, MyGLM2, test = "Chi")
```

---
# D√©fi 3 : solution ![:cube]()

.small[
```{r}
# GLM Poisson
glm.p = glm(Galumna~WatrCont+SubsDens, data=mites, family=poisson)
# GLM quasi-Poisson
glm.qp = update(glm.p,family=quasipoisson)
# s√©lection du mod√®le
drop1(glm.qp, test = "Chi")
```
```r
# ou
glm.qp2 = glm(Galumna~WatrCont, data=mites, family=quasipoisson)
anova(glm.qp2, glm.qp, test="Chisq")
```
]


---
# D√©fi 3 : solution ![:cube]()

<br>

.center[
```{r,echo=F, fig.height=5,fig.width=6}
glm.qp = glm(Galumna~WatrCont, data=mites, family=poisson)
glm.qp2 = update(glm.qp, family=quasipoisson)
pframe <- data.frame(WatrCont = 100:850)
pp <- predict(glm.qp2, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.qp2)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(mites$WatrCont, mites$Galumna,
      ylab = 'Nombre de Galumna', xlab = "Contenu d'eau du substrat (g/L)")
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]


---
# Autres distributions
<br>

- **Transformation logit des donn√©es** souvent utilis√©e avec `lm()` pour les pourcentages et les proportions quand la distribution binomiale n'est pas appropri√©e. Quand non selectionn√© √† partir de quantit√©s fix√©es (e.g. pourcentage de couverture, grades scolaires, etc).
- **Distribution log-normal dans un glm**, √©vite d'avoir √† log-transformer les donn√©es.
- **Distribution Gamma**. Similaire √† une log-normal, plus flexible.
- **Distribution tweedie**. Famille de distributions flexible. Utile pour des donn√©es avec un m√©lange de 0 et de valeurs positives (pas forc√©ment des comptes).
- **Poisson ou negative binomiale √† inflation de z√©ro**. Quand les donn√©es comprennent un nombre excessif de z√©ros, venant d'un processus diff√©rent de celui qui g√©n√®re les comptes.

---
class: inverse, center, middle

# GLMMs

<hr>
<br>

---
# R√©vision: Mod√®les Lin√©aires Mixtes

**Rappel de l'atelier LMM**:

- Structure dans le jeu de donn√©es ou corr√©lation entre les observations peut entra√Æner une **d√©pendance entre les observations** √©chantillonn√©s √† partir des m√™me sites ou points dans le temps
- On en tient compte en incluant des **termes d'effet al√©atoire**

**Effets al√©atoires**:

- Un √©chantillon de la population, i.e. les sujets que vous avez √©chantillonn√©s par hasard
- Explique la variation de la variable r√©ponse

**Effets fixes**:

- Reproductible, i.e serait le m√™me dans toutes les √©tudes
- Explique la moyenne de la variable r√©ponse

---
# R√©vision: Mod√®les Lin√©aires Mixtes

.pull-left[
**"Shrinkage estimates"**

- Les effets al√©atoires sont souvent appel√©s des **estimations de r√©tr√©cissement** parce qu'ils repr√©sentent une moyenne pond√©r√©e des donn√©es et de l'ajustement global (effet fixe)
- La baisse des coeff. vers l'ajustement global est plus s√©v√®re si la variabilit√© intra-groupe est grande par rapport √† la variabilit√© inter-groupe
]

.pull-right[
<br>
![](images/lmm.png)
]

---
# Ressources additionnelles sur les GLMMs

**Livres** :

- B. Bolker (2009) Ecological Models and Data in R. Princeton University Press.
- A. Zuur et al. (2009) Mixed Effects Models and Extensions in Ecology with R. Springer.

**Articles** :

- [Harrison et al. (2018), PeerJ, DOI 10.7717/peerj.4794
](http://dx.doi.org/10.7717/peerj.4794)

**Sites internet** :

- GLMM for ecologists (http://glmm.wikidot.com) .small[.comment[A great website on GLMM with a Q&A section!]]

---
class: inverse, center, bottom

# Merci pour votre participation √† cet atelier!

<hr>

![:scale 50%](images/qcbs_logo.png)

<br>
<br>
