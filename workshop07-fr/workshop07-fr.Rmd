---
title: "Atelier 7: Mod√®les lin√©aires g√©n√©ralis√©s (mixtes)"
subtitle: "S√©rie d'ateliers R"
author: "Centre de la Science de la Biodiversit√© du Qu√©bec"
output:
  xaringan::moon_reader:
    includes:
      in_header: qcbsR-header.html
    lib_dir: assets
    seal: true
    css: ["default", "qcbsR.css", "qcbsR-fonts.css"]
    nature:
      beforeInit: "qcbsR-macros.js"
      highlightLines: true
      highlightStyle: github
---


```{r setup, echo = FALSE}
knitr::opts_chunk$set(
  comment = "#",
  collapse = TRUE,
  cache = TRUE,
  warning = FALSE,
  message = FALSE,
  fig.width=6, fig.height=6,
  fig.retina = 3,
  fig.align = 'center'
)
mypar = list(mar = c(3,3,1,0.5), mgp = c(1.6, 0.3, 0), tck = -.02)
options(repos=structure(c(CRAN="http://cran.r-project.org")))
```


class: inverse, center, middle

```{R install_pkgs, echo = FALSE, results = "asis"}
cat(
  qcbsRworkshops::first_slides(7,
    c('ggplot2', 'lme4', 'MASS', 'vcdExtra', 'bbmle', 'DescTools'),
    lang = "fr")
)
```

---

# Objectifs d'apprentissage
<br>

##### 1. Pourquoi √™tre normal?
##### 2. GLM avec variable binaire
##### 3. GLM avec des donn√©es d'abondance
##### 4. GLM avec effet al√©atoires

---
class: inverse, center, middle

# Pourquoi √™tre normal?

<hr>

### Y aurait-il un meilleur mod√®le?


---
# Limitations des mod√®les lin√©aires (mixtes)

Charger les donn√©es et appliquer un mod√®le lin√©aire (`lm()`) :

```{r,echo=FALSE}
mites <- read.csv('data/mites.csv')
```

```{r,eval=F}
# v√©rifiez que vous √™tes dans le bon r√©pertoire de travail
mites <- read.csv('data/mites.csv')
head(mites)
str(mites)
```

Le jeu de donn√©es charg√© contient une partie du jeu de donn√©es classique des
[mites Oribatid (Acari,
Oribatei)](http://adn.biol.umontreal.ca/~numericalecology/data/oribates.html)
des sphaignes (Sphagnum sp.) du Lac Geai, [Station de Biologie de l'Universit√©
de Montreal](https://goo.gl/maps/PxN1Q7KUPnUt92Eu5) :

.small[
> 70 √©chantillons de mousses et mites

> 5 variables environmentales, abondance de la mite *Galumna sp.*, et abondance totale des mites
]

--

.alert[Objectif]: Mod√©liser l'abondance (`abund`), l'occurrence (`pa`), et la proportion (`prop`) de Galumna en fonction des 5 param√®tres environnementaux.



---
# Explorer les relations

Pouvons-nous voir une/des relation(s) entre *Galumna* et les 5 variables environnementales?

--

.pull-left2[
```{r,echo = -1}
par(mypar)
plot(mites)
```
]
.pull-right2[
<br><br><br><br>
`Galumna` vs `WatrCont`?!
]


---
# Explorer les relations

Une relation negative entre `Galumna` et le contenu en eau du sol?

```{r,fig.width=12,fig.height=4.5,echo=-1}
par(mypar)
par(mfrow = c(1, 3), cex = 1.4)
plot(Galumna ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Abondance')
boxplot(WatrCont ~ pa, data = mites, xlab='Pr√©sence/Absence', ylab = 'Contenu en eau')
plot(prop ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Proportion')
```

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

--
```{r, eval = -c(2, 4, 6)}
lm.abund <- lm(Galumna ~ WatrCont, data = mites)
summary(lm.abund)
lm.pa <- lm(pa ~ WatrCont, data = mites)
summary(lm.pa)
lm.prop <- lm(prop ~ WatrCont, data = mites)
summary(lm.prop)
```

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

.pull-left[
```{r}
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
summary(lm.abund)$coefficients[, 4]
```
]
.pull-right[
Un effet significatif dans tous les mod√®les!

.alert[Mais...]
]

---
# Tester la lin√©arit√©

Un effet significatif dans tous les mod√®les! .alert[Attends une minute...]

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(Galumna ~ WatrCont, data = mites)
abline(lm.abund)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.abund)
```
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Proportion `prop`) :

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(prop ~ WatrCont, data = mites)
abline(lm.prop)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.prop)
```
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Pr√©sence/Absence `pa`) :

.pull-left[
```{r,echo=-1}
par(mypar);par(cex = 1.4)
plot(pa ~ WatrCont, data = mites)
abline(lm.pa)
```
]

.pull-right[
```{r,echo=-1}
par(mypar)
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.pa)
```
]

---
# Conditions d'application du mod√®le lin√©aire

<br>

Il est **tr√®s commun** en √©cologie que les conditions d'application du mod√®le
lin√©aire ne soient pas respect√©es. C'est pourquoi nous avons souvent besoin des
**mod√®les lin√©aires g√©n√©ralis√©es** (GLMs).

<br>

.alert[Rafra√Æchissons-nous la m√©moire √† propos des conditions d'application du mod√®le lin√©aire.]

---
# Conditions d'application du mod√®le lin√©aire

√âquation du mod√®le:

$$y_i = \beta_0 + \beta_1x_i + \varepsilon_i$$

o√π:

- $y_i$ = valeur estim√©e pour la i<sup>√®me</sup> variable r√©ponse,
- $\beta_0$ = ordonn√©e √† l'origine de la droite,
- $\beta_1$ = pente,
- $x_i$ = i<sup>√®me</sup> valeur de la variable observ√©e.
- $\varepsilon_i$ = r√©sidus du mod√®le obtenus d'une distribution normale de moyenne 0 et de variance constante (qui est √† estimer).


---
# Distribution normale
<br>

Une autre mani√®re d'√©crire le mod√®le lin√©aire est :

$$Y_i \sim \mathcal{N}(\mu = \beta_0 + \beta_1x_i, \sigma^2)$$

<br>
Ce qui signifie que $y_i$ (r√©alisation de la variable al√©atoire $Y_i$) est √©chantillonn√©e dans une distribution normale ayant les param√®tres $\mu$ (dont la valeur d√©pend de $x_i$) et $\sigma$ (ind√©pendantes de $x_i$)

<br>
Essayons de pr√©dire l'abondance de `Galumna` en fonction du contenu d'eau en utilisant `lm()` que nous avons vu plus t√¥t.

---
# Distribution normale

**Rappel** : La distribution normale a deux param√®tres, $\mu$ (moyenne) et $\sigma$ (variance)

<br>
.pull-left[
3 valeurs pour $\mu$, $\sigma = 5$

```{r, echo=FALSE}
x = seq(1, 50, 0.1)
par(mypar);par(cex = 1.4)
plot(x, dnorm(x, mean = 20, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©')
points(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 30, sd = 5), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('20', '25', '30'), lty = 1, col = c(1, 2, 4), bty = 'n', lwd = 2, cex = 1.1)
```
]
.pull-right[
$\mu = 25$, 3 valeurs pour $\sigma$

```{r, echo=FALSE}
par(mypar);par(cex = 1.4)
x = seq(1, 50, 0.1)
plot(x, dnorm(x, mean = 25, sd = 5), type = 'l', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©')
points(x, dnorm(x, mean = 25, sd = 7.5), type = 'l', lwd = 3, col = 2)
points(x, dnorm(x, mean = 25, sd = 10), type = 'l', lwd = 3, col = 4)
legend('topleft', legend = c('5', '7.5', '10'), lty = 1, col = c(1, 2, 4), bty = 'n', lwd = 2, cex = 1.1)
```
]




---
# Distribution normales des r√©sidus

.large[.alert[Pour utiliser correctement le mod√®le lin√©aire, il faut s'assurer que les r√©sidus sont distribu√©s selon une loi normale centr√©e.]]

<br>

Il faut donc **v√©rifier la normalit√© des r√©sidus** et non celle la distribution de la variable de r√©ponse, comme le Andrew MacDonald dans un tweet √† propos de cette derni√®re pratique:

<blockquote class="twitter-tweet"><p lang="en" dir="ltr">This is the wrong thing to do because what matters is how your &quot;response variable&quot; is distributed *AFTER* you do your model, not before! <a href="https://twitter.com/rlmcelreath?ref_src=twsrc%5Etfw">@rlmcelreath</a> called this practice &quot;histomancy&quot;, which name I love</p>&mdash; Andrew MacDonald üåà (@polesasunder) <a href="https://twitter.com/polesasunder/status/1225100358738948101?ref_src=twsrc%5Etfw">February 5, 2020</a></blockquote> <script async src="https://platform.twitter.com/widgets.js" charset="utf-8"></script>
<br>



---
# Pr√©diction du mod√®le
<br>

Nous avons besoin des coefficients de r√©gression ( $\beta_0$ et $\beta_1$) et de $\sigma$ :

```{r}
coef(lm.abund)
summary(lm.abund)$sigma
```

Quels sont les param√®tres de la distribution normale utilis√©s pour mod√©liser $y$ lorsque le contenu d'eau = 300?

$$y_i \sim N(\mu = \beta_0 + \beta_1 x_i, \sigma^2)$$

--

$\mu = 3.44 + (-0.006 x 300) = 1.63$

$\sigma = 1.51$

---
# Pr√©diction du mod√®le

- Lorsque $x_i = 300$, $Y_i$ suit une distribution normale avec $\mu = 1.63$ et $\sigma^2 = 1.51$.

- Lorsque $x_i = 400$, $Y_i$ suit une distribution normale avec $\mu = 1.02$ et $\sigma^2 = 1.51$, etc.


<br>
Graphiquement, notre mod√®le ressemble √† :

--
.pull-left[
.center[
  ![:scale 100%](images/modelPredic.png)
]]

--
.pull-right[
**Probl√®mes**:
- $\sigma^2$ n'est pas homog√®ne, mais `lm()` nous contraint d'utiliser toujours la m√™me valeur de $\sigma^2$,
- Les valeurs estim√©es devraient √™tre des nombres entiers.
]

---
# Donn√©es biologiques & distributions

<br>

- Les statisticiens ont d√©velopp√© [de nombreuses lois de probabilit√© (distributions)](https://www.causascientia.org/math_stat/Dists/Compendium.pdf) correspondant √† divers types de donn√©es

- Une distribution donne la probabilit√© d'observer chaque issue possible d'une exp√©rience ou √©chantillonage (e.g. $abund = 8$ Galumna)

- Les distributions peuvent √™tre **discr√®tes** (que des nombres entiers) ou **continues** (incluent aussi des fractions)

- Toutes les distributions ont des **param√®tres** qui d√©terminent leur forme (e.g. $\mu$ et $\sigma^2$ pour la distribution normale)

---
# Donn√©es biologiques & distributions

L'abondance de *Galumna* suit une distribution discr√®te (que des nombres entiers). Pour mod√©liser les donn√©es d'abondance, la [loi de Poisson](https://fr.wikipedia.org/wiki/Loi_de_Poisson) est souvent utilis√©e:

- une distribution discr√®te avec un seul param√®tre, $\lambda$ (lambda), qui d√©termine la moyenne et la variance de la distribution:

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dpois(x, lambda = 1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 1')
plot(x, dpois(x, lambda = 10), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 10')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'lambda = 30')
```

---
# Donn√©es biologiques & distributions

*Galumna* semble suivre une loi de Poisson avec une faible valeur de $\lambda$ :

```{r}
  mean(mites$Galumna)
  hist(mites$Galumna)
```

---
# Donn√©es biologiques & distributions

Pr√©sence-absence par contre prend une autre forme :

- Inclut seulement des `0`s et des `1`s
- La loi de Poisson n'est pas appropri√©e pour cette variable

```{r, fig.height=4, echo=-1}
  par(mypar);par(cex=1.4)
  hist(mites$pa)
```

---
# Donn√©es biologiques & distributions

**Distribution de [Bernoulli](https://fr.wikipedia.org/wiki/Loi_de_Bernoulli)** :

- N'inclut que deux issues possibles dans son ensemble: succ√®s (`1`) ou √©chec (`0`)
- N'a qu'un param√®tre, $p$, la probabilit√© de succ√®s

<br>
```{r,echo=-F,fig.width=12,fig.height=4}
  par(mypar);par(mfrow = c(1, 3), cex=1.4)
  barplot(setNames(c(.9, .1), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.1')
  barplot(setNames(c(.5, .5), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.5')
  barplot(setNames(c(.1, .9), c('absent (0)', 'present (1)')), ylim = c(0, 1), xlab = 'pa', ylab = 'probability', main = 'p = 0.9')
```
Nous pouvons utiliser la loi de Bernoulli pour calculer la probabilit√© d'obtenir l'issue "Galumna present" (`1`) vs. "Galumna absent" (`0`)

---
# Donn√©es biologiques & distributions

**[Distribution binomiale](https://fr.wikipedia.org/wiki/Loi_binomiale)** : Lorsqu'il y a plusieurs √©preuves (chacune avec un succ√®s/√©chec), la loi de Bernoulli se transforme en loi binomiale

- Inclut le param√®tre additionel $n$, le nombre d'√©preuves
- Pr√©dit la probabilit√© d'observer une certaine proportion de succ√®s, $p$, sur le nombre total d'√©preuves, $n$

```{r,echo=F,fig.width=15}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 3), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.1), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.1 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.5), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.5 n = 50')
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probabilit√©', main = 'p = 0.9 n = 50')
```

---
# Donn√©es biologiques & distributions

**Distribution binomiale** : utilis√©e pour mod√©liser des donn√©es lorsque le nombre de succ√®s est donn√© par un nombre entier, et lorsque le nombre d'√©preuves, $n$, est connu.

**Diff√©rence principale avec la loi de Poisson** : L'√©tendue de la loi binomiale a une limite sup√©rieure, $n$. Par cons√©quent, elle est asym√©trique et d√©cal√©e √† gauche lorsque $p$ est faible, mais d√©cal√©e √† droite lorsque $p$ est √©lev√©.

```{r,echo=F,fig.width=10, fig.height=4}
x = seq(1, 50, 1)
par(mypar);par(mfrow = c(1, 2), cex = 1.4)
plot(x, dbinom(x, size = 50, prob = 0.9), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'p = 0.9 n = 50')
plot(x, dpois(x, lambda = 30), type = 'h', lwd = 3, xlab = '# galumna', ylab = 'Probability', main = 'lambda = 30')
```

---
# Donn√©es biologiques & distributions

Retournons √† notre probl√®me pour changer la distribution de $Y_i$ de normale √† Poisson :

$$Y_i \sim Poisson(\lambda = \beta_0 + \beta_1 x_i)$$

Le probl√®me est r√©solu!

1. $\lambda$ varie avec $x$ (contenu d'eau) et la variance des r√©sidus changera aussi avec $x$, et nous venons de nous d√©faire de la supposition d'homog√©n√©it√© de la variance!

2. Les valeurs estim√©es seront des nombres entiers plut√¥t que des nombres d√©cimaux;

3. Ce mod√®le ne pr√©dira jamais de valeurs n√©gatives (Poisson est toujours strictement positif).

---
# Donn√©es biologiques & distributions

Ce mod√®le est **presque** un GLM de Poisson, qui ressemble √† √ßa:

.center[![:scale 90%](images/poisPred.png)]

Les probabilit√©s (en orange) sont maintenant des nombres entiers, et la variance et la moyenne de la distribution d√©clinent lorsque $\lambda$ diminue avec le contenu d'eau.

---
class: inverse, center, middle

# GLM avec variable binaire

<hr>

---
# Variables binaires
<br>

Une variable r√©ponse commune dans les jeux de donn√©es en √©cologie : variable binaire, on observe un ph√©nom√®ne X ou son "absence"

- Pr√©sence/Absence d'une esp√®ce
- Pr√©sence/Absence d'une maladie
- Succ√®s/√âchec d'observer un comportement
- Survie/Mort d'un organisme

On veut d√©terminer si $P/A \sim Environment$

.comment[R√©gression logistique ou mod√®le logit]

---
# Variables binaires

Dans `R`, on code une variable binaire avec `1` et `0`:

```{r,echo=F}
Site <- LETTERS[1:6]
Presence <- c(1, 0, 1, 1, 0, 1)
dat = data.frame(Site, Presence)
```

<br>

.pull-left[
.right[
```{r, echo=F}
print(dat)
```
]]
.pull-right[
 <br>

 1 = Pr√©sence

 <br>

 0 = Absence
]

---
# Variables binaires


```{r,echo=F,fig.width=7, fig.height=6}
par(mypar);par(cex = 1.4)
hist(Presence)
```

.alert[Avec un mod√®le lin√©aires, les r√©sidus ne seront pas distribu√©s normalement!]

---
# Variables binaires

Les valeurs pr√©dites peuvent se trouver hors de l'intervalle `[0,1]` avec `lm()`:

<br>

```{r,echo=F,fig.width=7.5, fig.height=5.6}
Pres <- c(rep(1, 40), rep(0, 40))
rnor <- function(x) rnorm(1, mean = ifelse(x == 1, 12.5, 7.5), sd = 2)
ExpVar <- sapply(Pres, rnor)
par(mypar);par(cex = 1.4)
plot(ExpVar, Pres, ylim = c(-.5, 1.5), xlab = 'Variable explicative', ylab = 'Pr√©sence', main = "Valeurs pr√©dites d'un lm() avec une variable binaire", pch = 16)
abline(lm(Pres ~ ExpVar), col = 'orange', lwd = 2)
mtext(expression(symbol("\255")), at = 1.25, side = 4, line = 0.1, cex = 6, col = 'blue')
mtext(expression(symbol("\256")), at = 3, side = 1, line = -2.2, cex = 6, col = 'blue')
```

---
# Distribution de probabilit√©

La distribution de Bernoulli est adapt√©e pour des variables r√©ponses binaires

<br>

.pull-left[.right[

$E(Y) = p$

<br>

$Var(Y) = p \times (1 - p)$

]]
.pull-right[

![:faic](arrow-right) **Moyenne de la distribution** .small[Probabilit√© $p$ d'observer un r√©sultat]

![:faic](arrow-right) **Variance de la distribution** .small[La variance d√©cro√Æt quand $p$ est proche de `0` ou `1`]
]

---
# R√©gression logistique

La fonction `glm()`!

<br>

```R
logit.reg <- glm(formula, data, family)
```

<br>

Pour utiliser la bonne distribution, il faut sp√©cifier:

1. distribution de probabilit√©

--
**ET**

--
2. une [fonction de lien](https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function) (il y a une fonction de lien par d√©faut pour une distribution donn√©e!) qui d√©finit aussi une relation entre la moyenne et la variance.

<br>

--

Dans R, cela se fait en utilisant l'argument `family` (voir `?family`) :

---
# La fonction de lien

Pour un mod√®le lin√©aire de base d'une variable r√©ponse normalement distribu√©e, l'√©quation pour la valeur attendue est :

$$\mu = x\beta$$

o√π

- $\mu$ repr√©sente les valeurs pr√©dites par le mod√®le,
- $x$ est la matrice du mod√®le (*i.e.* les variables explicatives),
- $\beta$ est le vecteur des param√®tres estim√©s (*i.e.* intercept & pente).


###### $x\beta$ est appel√© le **pr√©dicteur lin√©aire**

---
# La fonction de lien

$\mu = x\beta$ est vrai seulement pour la distribution normale

Si ce n'est pas le cas, on utilise une transformation $g$ sur $\mu$

$$g(\mu) = x\beta$$

o√π $g$ est appel√©e **fonction de lien**. Cela permet de travailler avec des distributions autres que la loi normale.

---
# La fonction de lien

Pour les donn√©es binaires, on utilise la transformation **logit** :

<br>

$$g(\mu) = log\left(\frac{\mu}{1-\mu}\right)$$

$\mu =$ variables pr√©dites (probabilit√© que $Y = 1$)

--

1. $\frac{\mu}{1-\mu}$ met les valeurs pr√©dites sur une √©chelle de  `0` √† `+Inf`
2. La transformer en log ce qui projette les valeurs pr√©dites sur entre`-Inf` √† `+Inf`

--

<br>

![:faic](arrow-right) Les valeurs pr√©dites **transform√©es** sont reli√©es **lin√©airement** au pr√©dicteur lin√©aire

---
# Exercice 1

Sp√©cifiez un mod√®le de r√©gression logistique avec le jeu de donn√©es mites.

```{r,eval=F}
#setwd('...')
mites <- read.csv("mites.csv", header = TRUE)
str(mites)

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
str(mites)
```

---
# Exercice 1

Sp√©cifiez un mod√®le de la pr√©sence et de l'absence de *Galumna sp.* en fonction du contenu en eau du sol et de la topographie.

```{r}
logit.reg <- glm(pa ~ WatrCont + Topo, data=mites,
family = binomial(link = "logit"))
```
```{r,eval=F}
summary(logit.reg)
```

---
# Exercice 1

.small[
```{r}
summary(logit.reg)
```
]

---
# D√©fi 1 ![:cube]()

En utilisant le jeu de donn√©es 'bacteria', sp√©cifiez un mod√®le de la pr√©sence de *H. influenzae* en fonction du traitement et de la semaine de test.

Commencez avec un mod√®le satur√© et trouvez le mod√®le le plus parcimonieux.


```{r}
#install.packages("MASS")
library(MASS)
data(bacteria)
str(bacteria)
```

---
# Solution ![:cube]()

```{r}
model.bact1 <- glm(y ~ trt * week, data = bacteria, family = binomial)
```

```{r}
model.bact2 <- glm(y ~ trt + week, data = bacteria, family = binomial)
```

```{r}
model.bact3 <- glm(y ~ week, data = bacteria, family = binomial)
```

```{r}
anova(model.bact1, model.bact2, model.bact3, test = "LRT")
```

---
# Interpr√©ter la sortie

Regardez √† nouveau les coefficients du mod√®le `logit.reg` :

```{r}
summary(logit.reg)$coefficients
```

La sortie indique que le contenu d'eau et la topographie sont significatifs

.comment[Mais comment interpr√®te-on les coefficients de la pente?]

---
# Interpr√©ter la sortie

Rappelez-vous que nous avons utilis√© une transformation logit!

Pour bien interpr√©ter les coefficients du mod√®le, il faut les utiliser avec la fonction de lien inverse ( $g^{-1}$ ):

$$g^{-1}(\beta_0 + \beta_1x)$$


<!-- La fonction exponentielle pour obtenir les cotes : $e^x$ -->

Dans notre exemple, la fonction $logit$ inverse est utiliser pour obtenir les probabilit√©s :

$$logit^{-1} = \frac{1}{1 + e^{-(\beta_0 + \beta_1 WatrCont + \beta_2 TopoHummock)}}$$


---
# Pouvoir pr√©dictif et ajustement du mod√®le
<br>

Le [pseudo-R¬≤](https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/), un concept analogue au $R^2$ pour les mod√®les estim√©s par maximisation de la vraisemblance:

$$\text{pseudo-R}^2 = \frac{\text{d√©viance nulle - d√©viance r√©siduelle}}{\text{d√©viance nulle}}$$

<br>

$\text{pseudo-R}^2 = \text{variance expliqu√©e par le mod√®le}$

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Comparer la d√©viance du mod√®le (d√©viance r√©siduelle) √† la d√©viance d'un mod√®le nul (d√©viance nulle)

Le **mod√®le nul** est un mod√®le sans variables explicatives, simplement l'ordonn√©e √† l'origine

```R
null.model <- glm(Response.variable ~ 1, family = binomial)
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :

```{r}
objects(logit.reg)
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :

```{r}
pseudoR2 <- (logit.reg$null.deviance - logit.reg$deviance) / logit.reg$null.deviance
pseudoR2
```

.comment[Ainsi, le mod√®le explique 46.6% de la variabilit√© des donn√©es]

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Nouvelle statistique - **coefficient de discrimination (D)** √©value le pouvoir pr√©dictif d'une r√©gression logistique

- Mesure √† quel point la r√©gression logistique est capable de bien classifier un r√©sultat en succ√®s ou √©chec

Pour √©valuer l'ajustement du mod√®le, les graphiques de diagnostique ne sont pas utiles, il vaut mieux utiliser le [test de Hosmer-Lemeshow](https://en.wikipedia.org/wiki/Hosmer%E2%80%93Lemeshow_test):

- Compare le nombre de r√©sultats obtenus et attendus
- Similaire √† un test de $Chi^2$

---
# Exercice 2

La fonction R `PseudoR2` dans le package` DescTools` permet de calculer plusieurs Pseudo R2. En sp√©cifiant `which = all`, calculez toutes les statistiques en m√™me temps.


```{r, echo = -1}
logit.reg <- glm(mites$pa ~ mites$WatrCont + mites$Topo, family = binomial(link = "logit")) # needed for the rmd presentation, or else problem with PseudoR2 environment...
library(DescTools)
fit <- PseudoR2(logit.reg, which = "all")
fit
```

---
# Exercice 2: Faites le test de Hosmer-Lemeshow

```{r}
library(vcdExtra)
HLtest(logit.reg)
```

.comment[Une valeur non significative indique un ajustement ad√©quat!]


---
# D√©fi 2 ![:cube]()
<br>


1. En utilisant le mod√®le cr√©√© avec le jeu de donn√©es 'bacteria', √©valuez le pouvoir pr√©dictif et l'ajustement de ce mod√®le.

2. Comment faire pour am√©liorer le pouvoir explicatif du mod√®le?

---
# Solution ![:cube]()

1 :
```{r,eval=F}
null.d <- model.bact2$null.deviance
resid.d <- model.bact2$deviance
bact.pseudoR2 <- (null.d - resid.d) / null.d
HLtest(model.bact2)
```

2 : Ajouter des variables explicatives pertinentes pourrait certainement augmenter le pouvoir explicatif du mod√®le.

---
# GLM et donn√©es de proportions

Parfois, les donn√©es de proportions sont plus similaires √† un r√©gression logistique que ce que vous pensez...

Si on mesure un nombre d'occurences et qu'on conna√Æt la taille d'√©chantillon, on obtient des donn√©es de proportions!

Supposons qu'on mesure la pr√©valence d'une maladie sur dix cerfs dans 10 populations diff√©rentes :

.pull-left[

$$\frac{x\,\, \text{infected deer}}{10\,\,\text{deer}}$$

]

.pull-right[
![:faic](arrow-right) toujours entre `0` et `1`!
]

---
# Exercice 3

Dans R, on doit sp√©cifier le nombre de fois qu'un √©v√©nement s'est produit et le nombre de fois qu'un √©v√©nement ne s'est pas produit:

```{r}
prop.reg <- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial)
```

```r
summary(prop.reg)
```

---
# Exercice 3

.small[
```{r}
summary(prop.reg)
```
]

---
# Exercice 3

On peut coder le mod√®le directement avec les proportions:

```{r}
prop.reg2 <- glm(prop ~ Topo + WatrCont, data = mites,
                 family = binomial, weights = totalabund)
```

---
class: inverse, center, middle

# GLM avec des donn√©es d'abondance

<hr>

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Importez le jeu de donn√©es `faramea.csv` dans R

```{r,echo=F}
faramea <- read.csv('data/faramea.csv', header = TRUE)
```
```{r,eval=F}
faramea <- read.csv('faramea.csv', header = TRUE)
```

Le nombre d'arbres de l'esp√®ce *Faramea occidentalis* a √©t√© compt√© dans 43 quadrats sur l'√Æle de Barro Colorado (Panama). Des donn√©es environnementales, comme l'√©l√©vation et la pr√©cipitation ont aussi √©t√© mesur√©es.

Examinons maintenant √† quoi ressemble la distribution du nombre d'arbres par transect.

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

```{r, echo=F,fig.height=5}
par(mypar);par(cex = 1.4)
hist(faramea$Faramea.occidentalis, breaks = 30, col = 'gray', xlab = 'Nombre de F. occidentalis', ylab = 'Fr√©quence', main = '')
```

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Les donn√©es d'abondance sont charact√©ris√©es par:

- des valeurs positives : on ne peut pas compter -7 individus
- des valeurs enti√®res : on ne peut pas compter 7.56 individus
- une plus grande variance pour les fortes valeurs

---
# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

```{r, echo=F,fig.height=5}
par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Nombre de F. occidentalis', xlab = '√âlevation(m)')
```

---
# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

La **distribution de Poisson** semble √™tre le choix parfait pour mod√©liser ces donn√©es, ainsi des **GLMs Poisson** sont g√©n√©ralement une bonne fa√ßon pour commencer √† mod√©liser des donnes d'abondance.

---
# La distribution de Poisson

La distribution de poisson, qui sp√©cifie la probabilit√© d'une variable al√©atoire discr√®te Y, est donn√©es par :

$$f(y, \,\mu)\, =\, Pr(Y = y)\, =\, \frac{\mu^y \times e^{-\mu}}{y!}$$

$$E(Y)\, =\, Var(Y)\, =\, \mu$$

**Propri√©t√©s** :

- $\mu$ est le param√®tre de la distribution de Poisson
- sp√©cifie la probabilit√© pour des valeurs enti√®res uniquement
- la probabilit√© pour des valeurs n√©gatives est nulle ( $P(Y<0) = 0$)
- moyenne = variance (permet l'h√©t√©rog√©n√©it√©)

---
# Que se cache-t-il derri√®re un GLM Poisson?

Un GLM Poisson va mod√©liser la valeur de $\mu$ en fonction de diff√©rentes variables explicatives.

.center[**Trois √©tapes**]

**√âtape 1.** On suppose que $Y_i$ suit une distribution de Poisson de moyenne et variance $\mu_i$

$$Y_i = Poisson(\mu_i)$$

$$E(Y_i) = Var(Y_i) = \mu_i$$

$$f(y_i, \, \mu_i) = \frac{\mu^{y_i}_i \times e^{-\mu_i}}{y!}$$

$\mu_i$ correspond au nombre attendu d'individus

---
# Que se cache-t-il derri√®re un GLM Poisson?

**√âtape 2.** On sp√©cifie le pr√©dicteur lin√©aire comme dans un mod√®le lin√©aire

$$\underbrace{\alpha}_\text{One intercept} + \underbrace{\beta}_\text{slope of 'Elevation'} \times \text{Elevation}_i$$

**√âtape 3.** La fonction de lien entre la moyenne de $Y_i$ et la partie syst√©matique est un log

$$log(\mu_i) = \alpha + \beta \times \text{Elevation}_i$$

.center[ou]

$$\mu_i = e^{ \alpha + \beta \times \text{Elevation}_i}$$

---
# Ajuster un GLM Poisson sous R

La fonction `glm()` permet de sp√©cifier un GLM Poisson

```{r}
glm.poisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=poisson)
```

L'argument `family` permet de sp√©cifier le type de distribution et la fonction de lien (log)

<br>

Tout comme avec `lm()`, vous pouvez acc√©der au r√©sum√© du mod√®le √† l'aide de la fonction `summary()`

```{r,eval=F}
summary(glm.poisson)
```

---
# R√©sum√© du mod√®le

.pull-left2[
.small[
```{r}
summary(glm.poisson)
```
]]

.pull-right2[
Estim√©s :

Intercept = $\alpha$

√âlevation = $\beta$

]

--

.pull-right2[
<br>
Qu'en est-il de `Null deviance` et `Residual deviance`?!
]


---
# Estimation des param√®tres

Dans notre mod√®le, les param√®tres √† estimer sont l'ordonn√©e √† l'origine ( $\alpha$ ) et le coefficient de r√©gression de l'√©levation ( $\beta$ )


$$log(\mu_i) = 1.769 - 0.0027 \times \text{√âlevation}_i$$

.center[ou]

$$\mu_i = e^{1.769 - 0.0027 \times \text{√âlevation}_i}$$


---
# La d√©viance

Rappelez vous que pour estimer les param√®tres inconnus, l'estimation par maximum de vraisemblance est utilis√©e

La d√©viance r√©siduelle est approximativement la diff√©rence entre la vraisemblance d'un mod√®le satur√© (n param√®tres pour chaque observation) et le mod√®le complet (p param√®tres):

$$\text{Res dev} = 2 \, log(L(y;\,y)) - 2 \, log(L(y;\, \mu))$$

Dans un GLM Poisson, la d√©viance r√©siduelle doit √™tre √©gale au nombre de degr√©s de libert√© r√©siduels

.center[.alert[388.12 >> 41]]

---
# La surdispersion

Quand la d√©viance r√©siduelle est sup√©rieure au nombre de degr√©s de libert√© r√©siduels, le mod√®le est **surdispers√©**

$$\phi ~ = ~\frac{\text{D√©viance r√©siduelle}}{\text{Degr√©s de libert√© r√©siduels}}$$

Se produit lorsque la variance dans les donn√©es est plus grande que la moyenne. Dans ce cas la distribution de Poisson n'est plus appropri√©e (beaucoup de z√©ros, covariables manquantes, etc.)

.center[.large[**Solutions**]]

.pull-left[
1: Corriger la surdispersion en utilisant en **GLM quasi-Poisson**
]

.pull-right[
2: Choisir une autre distribution : **la [negative binomial](https://fr.wikipedia.org/wiki/Loi_binomiale_n%C3%A9gative)**
]

---
# GLM Quasi-Poisson

La variance du mod√®le tient compte de la **surdispersion** en ajoutant le param√®tre de surdispersion:

$$E(Y_i) = \mu_i$$

$$Var(Y_I) = \phi \times \mu_i$$

le **pr√©dicteur lin√©aire** et la **fonction de lien** restent les m√™me

$\phi$ est le param√®tre de dispersion. Il sera estim√© avant les param√®tres. Corriger pour la surdispersion ne va pas affecter l'estimation des param√®tres, mais leur **significativit√©**. En effet, les √©carts-types des param√®tres seront multipli√©s par $\sqrt{\phi}$.

.alert[Certaines p-values marginalement significatives peuvent devenir non significatives!]

---
# Ajuster un GLM quasi-Poisson sous R

Cr√©ez un nouveau GLM √† l'aide de la famille 'quasipoisson' ou actualisez le mod√®le pr√©c√©dent:

```{r}
glm.quasipoisson = glm(Faramea.occidentalis ~ Elevation, data = faramea,
                       family=quasipoisson)
glm.quasipoisson = update(glm.poisson, family = quasipoisson)
```

---
# Ajuster un GLM quasi-Poisson sous R

.pull-left2[
.small[
```{r}
summary(glm.quasipoisson)
```
]]
.pull-right2[
**M√™mes estim√©s mais**

.small[Les √©carts-types des param√®tres sont multipli√©s par]

$$\sqrt{\phi} = 4$$

`0.0006436 * 4 = 0.00257`

<- $\phi$

<br>

<- .small[Pas d'AIC!]
]

---
# Ajuster un GLM quasi-Poisson sous R

Testons l'effet de l'√©l√©vation par une analyse de d√©viance :

```{r}
null.model <- glm(Faramea.occidentalis ~ 1, data = faramea,
                  family = quasipoisson)
anova(null.model, glm.quasipoisson, test = "Chisq")
```

---
# Param√®tre de dispersion

.center[![:scale 80%](images/dispParam.png)]

---
# GLM binomiale n√©gative

Une distribution binomiale n√©gative est favoris√©e quand la surdispersion est forte

- La distribution a **deux param√®tres** $\mu$ and $k$. $k$ contr√¥le pour la dispersion (plus la dispersion est forte, plus $k$ est petit)
- C'est une combinaison de deux distributions (**Poisson** et **gamma**)
- Les $Y_i$ suivent une distribution de Poisson dont la moyenne $\mu$ suit une distribution Gamma!

$$E(Y_i) = \mu_i$$

$$Var(Y_i) = \mu_i + \frac{\mu^2_i}{k}$$


---
# Ajuster une binomiale n√©gative sous R

NB La distribution binomiale n'est pas dans la fonction `glm()` donc il faut installer et charger la paquet `MASS`

```r
install.packages('MASS')
```

```{r}
glm.negbin = glm.nb(Faramea.occidentalis ~ Elevation, data = faramea)
```

```r
summary(glm.negbin)
```

---
# Ajuster une binomiale n√©gative sous R

.pull-left2[
.small[
```{r,echo=-1}
summary(glm.negbin)
```
]]
.pull-right2[

<br><br><br><br><br><br><br><br><br><br><br><br><br>
`theta` $= k$
]

---
# Repr√©senter le mod√®le final

**√âtape 1** Repr√©senter les donn√©es et utiliser les estimations des param√®tres pour repr√©senter le mod√®le

$$\mu_i = e^{2.369 - 0.007 \times Elevation_i}$$

Utilisez `summary()` pour obtenir les param√®tres

```r
summary(glm.negbin)$coefficients[1, 1]
summary(glm.negbin)$coefficients[2, 1]
```

---
# Repr√©senter le mod√®le final

**√âtape 2** Utilisez les √©carts-types pour construire l'intervalle de confiance

```r
summary(glm.negbin)$coefficients[1, 2]
summary(glm.negbin)$coefficients[2, 2]
```

$$\text{Limite sup} = e^{[\alpha - 1.96 \times SE_{\alpha}] + [\beta - 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$

$$\text{Limit inf} = e^{[\alpha + 1.96 \times SE_{\alpha}] + [\beta + 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$

---
# Repr√©senter le mod√®le final

.small[
```{r,eval=F}
pp <- predict(glm.negbin, newdata = data.frame(Elevation = 1:800), se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function
pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
sc <- abs(qnorm((1-0.95)/2))  ## Normal approx. to likelihood
pframe <- transform(pframe, lwr = linkinv(pred0-sc*pp$se.fit), upr = linkinv(pred0+sc*pp$se.fit))
# sinon, utiiser predic() avec type="response"

plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]

```{r,echo=F, fig.height=4}
pframe <- data.frame(Elevation = 1:800)
pp <- predict(glm.negbin, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.negbin)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(faramea$Elevation, faramea$Faramea.occidentalis,
      ylab = 'Nombre de F. occidentalis', xlab = '√âlevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```

---
# D√©fi 3 ![:cube]()


Utilisez le jeu de donn√©es `mites`! Mod√©lisez l'abondance de l'esp√®ce *Galumna* en fonction des caract√©ristiques du substrat (son contenu en eau `WatrCont` et sa densit√© `SubsDens`)

- Faut-il contr√¥ler pour la surdispersion?
- Quelles variables explicatives ont un effet significatif?
- Selectionnez le meilleur mod√®le!

```{r,echo=F}
mites <- read.csv("data/mites.csv", header = TRUE)
```
```{r,eval=F}
mites <- read.csv("mites.csv", header = TRUE)
```

---
# D√©fi 3 : conseils ![:cube]()

S√©lection pas √† pas en retirant √† chaque fois une variable et en comparant le mod√®le emboit√© au mod√®le complet :

```r
drop1(MyGLM, test = "Chi")
```

Sp√©cifiez un mod√®le embo√Æt√© manuellement, appelez le `MyGLM2`, et utilisez la fonction anova():

```r
anova(MyGLM, MyGLM2, test = "Chi")
```

---
# D√©fi 3 : solution ![:cube]()

.small[
```{r}
# GLM Poisson
glm.p = glm(Galumna~WatrCont+SubsDens, data=mites, family=poisson)
# GLM quasi-Poisson
glm.qp = update(glm.p,family=quasipoisson)
# s√©lection du mod√®le
drop1(glm.qp, test = "Chi")
```
```r
# ou
glm.qp2 = glm(Galumna~WatrCont, data=mites, family=quasipoisson)
anova(glm.qp2, glm.qp, test="Chisq")
```
]


---
# D√©fi 3 : solution ![:cube]()

<br>

.center[
```{r,echo=F, fig.height=5,fig.width=6}
glm.qp = glm(Galumna~WatrCont, data=mites, family=poisson)
glm.qp2 = update(glm.qp, family=quasipoisson)
pframe <- data.frame(WatrCont = 100:850)
pp <- predict(glm.qp2, newdata = pframe, se.fit = TRUE)
linkinv <- family(glm.qp2)$linkinv ## inverse-link function

pframe$pred0 <- pp$fit
pframe$pred <- linkinv(pp$fit)
alpha <- 0.95
sc <- abs(qnorm((1-alpha)/2))  ## Normal approx. to likelihood
alpha2 <- 0.5
pframe <- transform(pframe,
                    lwr=linkinv(pred0-sc*pp$se.fit),
                    upr=linkinv(pred0+sc*pp$se.fit))

par(mypar);par(cex = 1.4)
plot(mites$WatrCont, mites$Galumna,
      ylab = 'Nombre de Galumna', xlab = "Contenu d'eau du substrat (g/L)")
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]


---
# Autres distributions
<br>

- **Transformation logit des donn√©es** souvent utilis√©e avec `lm()` pour les pourcentages et les proportions quand la distribution binomiale n'est pas appropri√©e. Quand non selectionn√© √† partir de quantit√©s fix√©es (e.g. pourcentage de couverture, grades scolaires, etc).
- **Distribution log-normal dans un glm**, √©vite d'avoir √† log-transformer les donn√©es.
- **Distribution Gamma**. Similaire √† une log-normal, plus flexible.
- **Distribution tweedie**. Famille de distributions flexible. Utile pour des donn√©es avec un m√©lange de 0 et de valeurs positives (pas forc√©ment des comptes).
- **Poisson ou negative binomiale √† inflation de z√©ro**. Quand les donn√©es comprennent un nombre excessif de z√©ros, venant d'un processus diff√©rent de celui qui g√©n√®re les comptes.

---
class: inverse, center, middle

# GLMMs

<hr>
<br>

---
# R√©vision: Mod√®les Lin√©aires Mixtes

**Rappel de l'atelier LMM**:

- Structure dans le jeu de donn√©es ou corr√©lation entre les observations peut entra√Æner une **d√©pendance entre les observations** √©chantillonn√©s √† partir des m√™me sites ou points dans le temps
- On en tient compte en incluant des **termes d'effet al√©atoire**

**Effets al√©atoires**:

- Un √©chantillon de la population, i.e. les sujets que vous avez √©chantillonn√©s par hasard
- Explique la variation de la variable r√©ponse

**Effets fixes**:

- Reproductible, i.e serait le m√™me dans toutes les √©tudes
- Explique la moyenne de la variable r√©ponse

---
# R√©vision: Mod√®les Lin√©aires Mixtes

.pull-left[
**"Shrinkage estimates"**

- Les effets al√©atoires sont souvent appel√©s des **estimations de r√©tr√©cissement** parce qu'ils repr√©sentent une moyenne pond√©r√©e des donn√©es et de l'ajustement global (effet fixe)
- La baisse des coeff. vers l'ajustement global est plus s√©v√®re si la variabilit√© intra-groupe est grande par rapport √† la variabilit√© inter-groupe
]

.pull-right[
<br>
![](images/lmm.png)
]


---
# Mod√®les Lin√©aires G√©n√©ralis√©s Mixtes (GLMMs)

Extension des GLMs tenant compte de structures suppl√©mentaires dans les donn√©es

Suivre les √©tapes similaires √† celles introduites lors de l'atelier sur les LMMs:

1. LMMs incorporent les effets al√©atoires
2. GLMs peuvent g√©rer des donn√©es non-normales (en laissant les erreurs prendre diff√©rentes familles de distribution - e.g Poisson ou binomial n√©gatif)

---
# Comment mod√©liser un GLM sous R

Chargez les donn√©es `Arabidopsis` `banta_totalfruits.csv` dans R.

```{r, echo=F}
dat.tf <- read.csv("data/banta_totalfruits.csv")
```

```r
dat.tf <- read.csv("banta_totalfruits.csv")
```
```r
# popu facteur avec un niveau pour chaque population
# gen facteur avec un niveau pour chaque g√©notype
# nutrient facteur avec niveau bas (valeur = 1) ou haut (valeur = 8)
# amd facteur pr√©cisant l'absence ou la pr√©sence d'herbivorie
# total.fruits nombre entier indiquant le nombre de fruits par plante
```

L'effet de la disponibilit√© de nutriments et d'herbivorie (**effets fixes**) sur la production de fruits d'*Arabidopsis thaliana* (arabette des dames) a √©t√© √©valu√© en mesurant 625 plantes √† travers neuf populations diff√©rentes, constitu√©es chacune de 2 √† 3 g√©notypes (**effets al√©atoires**)


---
# Choisir la distribution des erreurs

La variable r√©ponse constitue des donn√©es d'abondance, donc nous devons choisir une **distribution de Poisson** (i.e variance √©gale √† la moyenne)

```{r,echo=F, fig.height=5, fig.width=6}
par(mypar);par(cex = 1.4)
hist(dat.tf$total.fruits, breaks = 50, col = 'blue', main = '',
     xlab = 'Fruits totaux', ylab = 'Compte')
```
Cependant, comme nous le verrons, la variance de chaque groupe augmente beaucoup plus rapidement que pr√©vu...

---
# Exploration de la variance

Pour illustrer l'h√©t√©rog√©n√©it√© de la variance, nous allons d'abord cr√©er des bo√Ætes √† moustaches (boxplots) de la variable r√©ponse par rapport aux diff√©rents facteurs environnementaux

Cr√©ons de nouvelles variables qui repr√©sentent toutes les combinaisons de **nutriments** x **herbivorie** x **facteur al√©atoire**

```{r}
dat.tf <- within(dat.tf,
{
  # g√©notype x nutriment x herbivorie
  gna <- interaction(gen,nutrient,amd)
  gna <- reorder(gna, total.fruits, mean)
  # population x nutriment x herbivorie
  pna <- interaction(popu,nutrient,amd)
  pna <- reorder(pna, total.fruits, mean)
})
```

---
# Exploration de la variance

.small[
```{r, fig.height=3.5, fig.width=8}
# Boxplot du total des fruits vs interaction g√©notype x nutriment x herbivorie
library(ggplot2)
ggplot(data = dat.tf, aes(factor(x = gna),y = log(total.fruits + 1))) +
  geom_boxplot(colour = "skyblue2", outlier.shape = 21,
  outlier.colour = "skyblue2") +
  theme_bw() + theme(axis.text.x=element_blank()) +
  stat_summary(fun.y=mean, geom="point", colour = "red")
```
]

.comment[De m√™me, la bo√Æte √† moustaches total des fruits vs population x nutriments x herbivorie montre une grande quantit√© d'h√©t√©rog√©n√©it√© entre les populations.]


---
# Choisir la distribution des erreurs

Comme nous venons de le voir, il existe une importante h√©t√©rog√©n√©it√© parmi la variance de chaque groupe, m√™me lorsque la variable r√©ponse est transform√©e

Si nous repr√©sentons graphiquement les **√©carts vs moyennes par groupes** (g√©notypes x nutriment x herbivorie), on voit que la distribution de Poisson est la moins appropri√©e (i.e. √©cart augmentent beaucoup plus vite que la moyenne)

.small[.pull-left[
![](images/errDist.png)
]
.pull-right[

<font color="blue">NB = negative binomial</font>

<br>

<font color="red">QP = quasi-Poisson</font>

<br>
<font color="LightBlue">loess = Locally weighted regression smoothing</font>
]]


---
# GLMM Poisson

Compte tenu de la relation moyenne-variance, nous avons besoin d'un mod√®le avec surdispersion.

- Mais commen√ßons avec un mod√®le de Poisson :

Pour lancer un GLMM dans R, nous faisons appel √† la fonction `glmer()`, du paquet lme4

```{r}
library(lme4)
mp1 <- glmer(total.fruits ~ nutrient*amd + rack + status +
             (1|popu)+
             (1|gen),
             data = dat.tf, family = "poisson")
```

**Effets al√©atoires** : `(1|popu)` contient un intercept al√©atoire partag√© par les mesures qui ont la m√™me valeur pour `popu`

---
# V√©rification de la surdispersion

Nous pouvons v√©rifier la surdispersion en utilisant la fonction `overdisp_fun()` (Bolker *et al*. 2011) qui divise la d√©viance des r√©sidus (r√©sidus de Pearson) par les degr√©s de libert√© des r√©sidus et teste si le rapport est plus grand que 1

```{r}
# T√©l√©chargez le code glmm_funs.R de la page wiki et sourcez le pour ex√©cuter la fonction dans R
source(file="data/glmm_funs.R")
# Surdispersion?
overdisp_fun(mp1)
```

- Ratio est significativement $>>$ 1
- Comme on s'y attendait, nous devons mod√©liser une distribution diff√©rente o√π la variance augmente plus rapidement que la moyenne

---
# GLMM binomiale negative .small[(Poisson-gamma)]

La distribution binomiale n√©gative satisfait la supposition que la **variance est proportionnelle au carr√© de la moyenne**

```{R}
mnb1 <- glmer.nb(total.fruits ~ nutrient*amd + rack + status +
                 (1|popu)+
                 (1|gen),
                 data=dat.tf, control=glmerControl(optimizer="bobyqa"))
# Control sp√©cifie la fa√ßon dont nous optimisons les valeurs des param√®tres
```

.pull-left[
```r
# Surdispersion?
overdisp_fun(mnb1)
```
]
.pull-right[
![:faic](arrow-left).small[.alert[Le rapport est maintenant beaucoup plus pr√®s de 1 mais la valeur de p < 0.05]]
]

---
# GLMM Poisson-lognormal

- Un autre option est la distribution **Poisson-lognormal**.
- Cela peut √™tre r√©alis√© simplement en pla√ßant un effet al√©atoire de niveau d'observation dans la formule.
.small[
```{r}
mpl1 <- glmer(total.fruits ~ nutrient*amd + rack + status +
              (1|X) +
              (1|popu)+
              (1|gen),
data=dat.tf, family="poisson",
control = glmerControl(optimizer = "bobyqa"))
```

`(1|X)` traite de la surdispersion en ajoutant des **effets al√©atoires au niveau de l'observation**

```{r}
overdisp_fun(mpl1)
```

.alert[Rapport maintenant conforme avec notre crit√®re]
]

---
# GLMM Poisson-lognormal

**Repr√©sentation graphique des param√®tres du mod√®le**: Une repr√©sentation graphique des param√®tres du mod√®le peut √™tre obtenue en utilisant la fonction `coefplot2()`du paquet `coefplot2`:

--

.alert[![:faic](warning) Ce paquet n'est pas sur le CRAN! On utilise le package remotes pour l'installer depuis GitHub]

```{R install_coefplot2}
if (!require("coefplot2"))
  remotes::install_github("palday/coefplot2", subdir = "pkg")
library(coefplot2)
```

---
# GLMM Poisson-lognormal


.pull-left[
```{r, fig.height=5, fig.width=6, echo=-1}
par(mypar);par(cex = 1.4)
# Param√®tres de la variance
coefplot2(mpl1, ptype = "vcov", intercept = TRUE)
```
]
.pull-right[
```{r, fig.height=5, fig.width=6,echo=-1}
par(mypar);par(cex = 1.4)
# Effets fixes
coefplot2(mpl1, intercept = TRUE)
```
]

.alert[Note]: barres d'erreur visibles seulement pour les effets fixes parce que glmer ne nous donne pas d'informations sur l'incertitude des effets al√©atoires.

---
# Visualisation des effets al√©atoires

Vous pouvez aussi extraire les effets al√©atoires en utilisant la fonction `ranef()` et les tracer en utilisant un `dotplot()` du paquet `lattice`

Il y a une variabilit√© r√©gionale parmi les populations :

- Les populations espagnoles (SP) ont des valeurs plus √©lev√©es que les populations su√©doises (SW) et n√©erlandaises (NL)

La diff√©rence entre les g√©notypes semble largement induite par g√©notype 34

```r
library(gridExtra)
library(lattice)
# dotplot code
pp <- list(layout.widths=list(left.padding=0, right.padding=0),
           layout.heights=list(top.padding=0, bottom.padding=0))
r2 <- ranef(mpl1, condVar = TRUE)
d2 <- dotplot(r2, par.settings = pp)
grid.arrange(d2$gen, d2$popu, nrow = 1)
```

---
# Visualisation des effets al√©atoires

<br>

```{r, echo= FALSE, fig.width=9}
library(gridExtra)
library(lattice)
pp <- list(layout.widths=list(left.padding=0, right.padding=0),
           layout.heights=list(top.padding=0, bottom.padding=0))
r2 <- ranef(mpl1, condVar = TRUE)
d2 <- dotplot(r2, par.settings = pp, scales=list(x=list(cex=1.4),y=list(cex=1.3)))
grid.arrange(d2$gen, d2$popu, nrow = 1)
```


---
# S√©lection du mod√®le

Les m√™me m√©thodes peuvent √™tre utilis√©es avec un glmm ou lmm pour choisir entre des mod√®les avec diff√©rents intercepts al√©atoires et/ou des pentes al√©atoires et pour choisir les effets fixes √† conserver dans le mod√®le final.

- une **approche de la th√©orie de l'information** (e.g., AICc - Atelier 5)
- une **approche fr√©quentiste** (o√π l'importance de chaque terme est √©valu√©e en utilisant `anova()` et le test de rapport de vraisemblance; LRT)


---
# S√©lection du mod√®le

Nous d√©rivons d'abord les mod√®les potentiels et les comparons en utilisant AICc.comment[*]:

```{r}
mpl2 <- update(mpl1, . ~ . - rack) # mod√®le sans rack
mpl3 <- update(mpl1, . ~ . - status) # mod√®le sans status
mpl4 <- update(mpl1, . ~ . - amd:nutrient) # mod√®le sans interaction amd:nutrient
bbmle::ICtab(mpl1, mpl2, mpl3, mpl4, type = c("AICc"))
```

.comment[*NB: Nous ne couvrons pas tous les mod√®les possibles ci-dessus, cependant, l'interaction `amd:nutriments` ne peut √™tre √©valu√©e que si amd et nutriments sont pr√©sents dans le mod√®le.
]


---
# S√©lection du mod√®le

Nous pouvons aussi utiliser les fonctions `drop1()` et `dfun()` pour √©valuer nos effets fixes (`dfun()` convertit les valeurs AIC retourn√©es par `drop1()` en valeurs $\Delta$AIC)

.small[
```{r}
dd_LRT <- drop1(mpl1,test="Chisq")
(dd_AIC <- dfun(drop1(mpl1)))
```
]

---
# S√©lection du mod√®le
.small[
```{r}
dd_LRT <- drop1(mpl1,test="Chisq")
(dd_AIC <- dfun(drop1(mpl1)))
```
]

- Fort effet de **rack** (dAIC = 55.08 si on enl√®ve cette variable)
- Effets de **status** et de l'**interaction** sont faibles (dAIC < 2)
- Commen√ßons par **enlever l'interaction non significative** afin de tester les effets principaux de nutriments et d'herbivorie

---
# S√©lection du mod√®le

<br>

.pull-left2[
```{r}
mpl2 <- update(mpl1, . ~ . - and:nutrient)
# Utiliser AIC
mpl3 <- update(mpl2, . ~ . - rack) # pas de rack ou interaction
mpl4 <- update(mpl2, . ~ . - status) # pas de status ou interaction
mpl5 <- update(mpl2, . ~ . - nutrient) # pas de nutrient ou interaction
mpl6 <- update(mpl2, . ~ . - amd) # pas d'herbivorie ou interaction
# bbmle::ICtab(mpl2, mpl3, mpl4, mpl5, mpl6,
#              type = c("AICc"))

# Ou utiliser drop1
dd_LRT2 <- drop1(mpl2,test="Chisq")
dd_AIC2 <- dfun(drop1(mpl2))
```
]
.pull-right2[
```{r}
library(bbmle)
ICtab(mpl2, mpl3 ,mpl4,
      mpl5, mpl6,
      type = c("AICc"))
```
]


---
# S√©lection du mod√®le
<br>

- Fort effets de **nutriments** et d'**herbivorie** (grand changement d'AIC de $135.6$ (`mpl5`) et $10.2$ (`mpl6`) si l'un ou l'autre sont supprim√©s, respectivement).
- Notre mod√®le final inclut l'effet fixe de nutriments, d'herbivorie, la variable nuisance de rack, l'effet al√©atoire au niveau de l'observation `(1|X)` et la variation de fruits par populations et g√©notypes.


---
# Pr√™t pour un d√©fi? ![:cube]()

En utilisant l'ensemble de donn√©es `inverts` (temps de d√©veloppement larvaire (`PLD`) de 74 esp√®ces d'invert√©br√©s et vert√©br√©s marins √©lev√©s √† diff√©rentes temp√©ratures et temps), r√©pondez aux questions suivantes:

- Quel est l'effet du type d'alimentation et du climat (**effets fixes**) sur `PLD`?
- Est-ce que cette relation varie selon les taxons (**effets al√©atoires**)?
- Quelle est la **meilleure famille de distributions** pour ces donn√©es?
- Finalement, une fois que vous avez d√©termin√© la meilleure famille de distribution, re-√©valuez vos effets fixes et al√©atoires.


---
# Solution

```{R, eval = FALSE}
# inverts <- read.csv('data/inverts.csv', header = TRUE)
# head(inverts)
# table(inverts$temp, inverts$feeding.type)
#
# mod.glm <- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)
# summary(mod.glm)
# drop1(mod.glm, test = "Chisq")
#
# boxplot(PLD ~ temp,  data = inverts)
# boxplot(PLD ~ feeding.type ,  data = inverts)
#
# boxplot(predict(mod.glm, type = "response")~inverts$temp)
#
# plot()
#
# modglm <- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)


#
# r2 <- ranef(mpl1, condVar = TRUE)
# d2 <- dotplot(r2, par.settings = pp)
#
#
# plot(aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2], pch = 19)
# abline(a=0, b = 1, lty =2)
#
# mod.glmer <- glmer.nb(PLD ~ temp + feeding.type + (1|taxon), data = inverts)
# mod.glm <- glm.nb(PLD ~ temp + feeding.type, family = poisson(), data = inverts)

```

plot(aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2])
abline(a=0, b =1, lty =2 )


---
# Ressources additionnelles sur les GLMMs

**Livres** :

- B. Bolker (2009) Ecological Models and Data in R. Princeton University Press.
- A. Zuur et al. (2009) Mixed Effects Models and Extensions in Ecology with R. Springer.

**Articles** :

- [Harrison et al. (2018), PeerJ, DOI 10.7717/peerj.4794
](http://dx.doi.org/10.7717/peerj.4794)

**Sites internet** :

- GLMM for ecologists (http://glmm.wikidot.com) .small[.comment[A great website on GLMM with a Q&A section!]]

---
class: inverse, center, bottom

# Merci pour votre participation √† cet atelier!

<hr>

![:scale 50%](images/qcbs_logo.png)

<br>
<br>
