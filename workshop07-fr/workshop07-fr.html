<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Atelier 7: Mod√®les lin√©aires g√©n√©ralis√©s (mixtes)</title>
    <meta charset="utf-8" />
    <meta name="author" content="Centre de la Science de la Biodiversit√© du Qu√©bec" />
    <link href="assets/remark-css-0.0.1/default.css" rel="stylesheet" />
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.8.6/css/academicons.min.css">
    <link rel="stylesheet" href="qcbsR.css" type="text/css" />
    <link rel="stylesheet" href="qcbsR-fonts.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, inverse, title-slide

# Atelier 7: Mod√®les lin√©aires g√©n√©ralis√©s (mixtes)
## S√©rie d‚Äôateliers R
### Centre de la Science de la Biodiversit√© du Qu√©bec

---






class: inverse, center, middle

# √Ä propos de cet atelier
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=repo&amp;message=dev&amp;color=6f42c1&amp;logo=github)](https://github.com/QCBSRworkshops/workshop07)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=wiki&amp;message=07&amp;logo=wikipedia)](https://wiki.qcbs.ca/r_atelier7)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=Diapos&amp;message=07&amp;color=red&amp;logo=html5)](https://qcbsrworkshops.github.io/workshop07/workshop07-fr/workshop07-fr.html)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=Diapos&amp;message=07&amp;color=red&amp;logo=adobe-acrobat-reader)](https://qcbsrworkshops.github.io/workshop07/workshop07-fr/workshop07-fr.pdf)
[![badge](https://img.shields.io/static/v1?style=for-the-badge&amp;label=script&amp;message=07&amp;color=2a50b8&amp;logo=r)](https://qcbsrworkshops.github.io/workshop07/workshop07-fr/workshop07-fr.R)

---

# Packages requis

* [ggplot2](https://cran.r-project.org/package=ggplot2)
* [lme4](https://cran.r-project.org/package=lme4)
* [MASS](https://cran.r-project.org/package=MASS)
* [vcdExtra](https://cran.r-project.org/package=vcdExtra)
* [bbmle](https://cran.r-project.org/package=bbmle)
* [DescTools](https://cran.r-project.org/package=DescTools)

&lt;br&gt;

```R
install.packages(c('ggplot2', 'lme4', 'MASS', 'vcdExtra', 'bbmle', 'DescTools'))
```

---

# Objectifs d'apprentissage
&lt;br&gt;

##### 1. Pourquoi √™tre normal?
##### 2. GLM avec variable binaire
##### 3. GLM avec des donn√©es d'abondance
##### 4. GLM avec effet al√©atoires

---
class: inverse, center, middle

# Pourquoi √™tre normal?

&lt;hr&gt;

### Y aurait-il un meilleur mod√®le?


---
# Limitations des mod√®les lin√©aires (mixtes)

Charger les donn√©es et appliquer un mod√®le lin√©aire (`lm()`) :




```r
# v√©rifiez que vous √™tes dans le bon r√©pertoire de travail
mites &lt;- read.csv('data/mites.csv')
head(mites)
str(mites)
```

Le jeu de donn√©es charg√© contient une partie du jeu de donn√©es classique des
[mites Oribatid (Acari,
Oribatei)](http://adn.biol.umontreal.ca/~numericalecology/data/oribates.html)
des sphaignes (Sphagnum sp.) du Lac Geai, [Station de Biologie de l'Universit√©
de Montreal](https://goo.gl/maps/PxN1Q7KUPnUt92Eu5) :

.small[
&gt; 70 √©chantillons de mousses et mites

&gt; 5 variables environmentales, abondance de la mite *Galumna sp.*, et abondance totale des mites
]

--

.alert[Objectif]: Mod√©liser l'abondance (`abund`), l'occurrence (`pa`), et la proportion (`prop`) de Galumna en fonction des 5 param√®tres environnementaux.



---
# Explorer les relations

Pouvons-nous voir une/des relation(s) entre *Galumna* et les 5 variables environnementales?

--

.pull-left2[

```r
plot(mites)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-3-1.png" width="432" style="display: block; margin: auto;" /&gt;
]
.pull-right2[
&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
`Galumna` vs `WatrCont`?!
]


---
# Explorer les relations

Une relation negative entre `Galumna` et le contenu en eau du sol?


```r
par(mfrow = c(1, 3), cex = 1.4)
plot(Galumna ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Abondance')
boxplot(WatrCont ~ pa, data = mites, xlab='Pr√©sence/Absence', ylab = 'Contenu en eau')
plot(prop ~ WatrCont, data = mites, xlab = 'Contenu en eau', ylab='Proportion')
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-4-1.png" width="864" style="display: block; margin: auto;" /&gt;

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

--

```r
lm.abund &lt;- lm(Galumna ~ WatrCont, data = mites)
## summary(lm.abund)
lm.pa &lt;- lm(pa ~ WatrCont, data = mites)
## summary(lm.pa)
lm.prop &lt;- lm(prop ~ WatrCont, data = mites)
## summary(lm.prop)
```

---
# Tester la lin√©arit√©

Utiliser des mod√®les lin√©aires pour voir si l'abondance, `abund`, la pr√©sence/absence, `pa`, et/ou la proportion, `prop`, varient en fonction du contenu d'eau.

.pull-left[

```r
summary(lm.abund)$coefficients[, 4]
#  (Intercept)     WatrCont 
# 3.981563e-08 1.206117e-05
summary(lm.abund)$coefficients[, 4]
#  (Intercept)     WatrCont 
# 3.981563e-08 1.206117e-05
summary(lm.abund)$coefficients[, 4]
#  (Intercept)     WatrCont 
# 3.981563e-08 1.206117e-05
```
]
.pull-right[
Un effet significatif dans tous les mod√®les!

.alert[Mais...]
]

---
# Tester la lin√©arit√©

Un effet significatif dans tous les mod√®les! .alert[Attends une minute...]

.pull-left[

```r
plot(Galumna ~ WatrCont, data = mites)
abline(lm.abund)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-7-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

.pull-right[

```r
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.abund)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-8-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Proportion `prop`) :

.pull-left[

```r
plot(prop ~ WatrCont, data = mites)
abline(lm.prop)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-9-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

.pull-right[

```r
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.prop)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-10-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

---
# Tester la lin√©arit√©

Encore pire pour les autres mod√®les (Pr√©sence/Absence `pa`) :

.pull-left[

```r
plot(pa ~ WatrCont, data = mites)
abline(lm.pa)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-11-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

.pull-right[

```r
par(mfrow = c(2, 2), cex = 1.4)
plot(lm.pa)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-12-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

---
# Conditions d'application du mod√®le lin√©aire

&lt;br&gt;

Il est **tr√®s commun** en √©cologie que les conditions d'application du mod√®le
lin√©aire ne soient pas respect√©es. C'est pourquoi nous avons souvent besoin des
**mod√®les lin√©aires g√©n√©ralis√©es** (GLMs).

&lt;br&gt;

.alert[Rafra√Æchissons-nous la m√©moire √† propos des conditions d'application du mod√®le lin√©aire.]

---
# Conditions d'application du mod√®le lin√©aire

√âquation du mod√®le:

`$$y_i = \beta_0 + \beta_1x_i + \varepsilon_i$$`

o√π:

- `\(y_i\)` = valeur estim√©e pour la i&lt;sup&gt;√®me&lt;/sup&gt; variable r√©ponse,
- `\(\beta_0\)` = ordonn√©e √† l'origine de la droite,
- `\(\beta_1\)` = pente,
- `\(x_i\)` = i&lt;sup&gt;√®me&lt;/sup&gt; valeur de la variable observ√©e.
- `\(\varepsilon_i\)` = r√©sidus du mod√®le obtenus d'une distribution normale de moyenne 0 et de variance constante (qui est √† estimer).


---
# Distribution normale
&lt;br&gt;

Une autre mani√®re d'√©crire le mod√®le lin√©aire est :

`$$Y_i \sim \mathcal{N}(\mu = \beta_0 + \beta_1x_i, \sigma^2)$$`

&lt;br&gt;
Ce qui signifie que `\(y_i\)` (r√©alisation de la variable al√©atoire `\(Y_i\)`) est √©chantillonn√©e dans une distribution normale ayant les param√®tres `\(\mu\)` (dont la valeur d√©pend de `\(x_i\)`) et `\(\sigma\)` (ind√©pendantes de `\(x_i\)`)

&lt;br&gt;
Essayons de pr√©dire l'abondance de `Galumna` en fonction du contenu d'eau en utilisant `lm()` que nous avons vu plus t√¥t.

---
# Distribution normale

**Rappel** : La distribution normale a deux param√®tres, `\(\mu\)` (moyenne) et `\(\sigma\)` (variance)

&lt;br&gt;
.pull-left[
3 valeurs pour `\(\mu\)`, `\(\sigma = 5\)`

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-13-1.png" width="432" style="display: block; margin: auto;" /&gt;
]
.pull-right[
`\(\mu = 25\)`, 3 valeurs pour `\(\sigma\)`

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-14-1.png" width="432" style="display: block; margin: auto;" /&gt;
]




---
# Distribution normales des r√©sidus

.large[.alert[Pour utiliser correctement le mod√®le lin√©aire, il faut s'assurer que les r√©sidus sont distribu√©s selon une loi normale centr√©e.]]

&lt;br&gt;

Il faut donc **v√©rifier la normalit√© des r√©sidus** et non celle la distribution de la variable de r√©ponse, comme le Andrew MacDonald dans un tweet √† propos de cette derni√®re pratique:

&lt;blockquote class="twitter-tweet"&gt;&lt;p lang="en" dir="ltr"&gt;This is the wrong thing to do because what matters is how your &amp;quot;response variable&amp;quot; is distributed *AFTER* you do your model, not before! &lt;a href="https://twitter.com/rlmcelreath?ref_src=twsrc%5Etfw"&gt;@rlmcelreath&lt;/a&gt; called this practice &amp;quot;histomancy&amp;quot;, which name I love&lt;/p&gt;&amp;mdash; Andrew MacDonald üåà (@polesasunder) &lt;a href="https://twitter.com/polesasunder/status/1225100358738948101?ref_src=twsrc%5Etfw"&gt;February 5, 2020&lt;/a&gt;&lt;/blockquote&gt; &lt;script async src="https://platform.twitter.com/widgets.js" charset="utf-8"&gt;&lt;/script&gt;
&lt;br&gt;



---
# Pr√©diction du mod√®le
&lt;br&gt;

Nous avons besoin des coefficients de r√©gression ( `\(\beta_0\)` et `\(\beta_1\)`) et de `\(\sigma\)` :


```r
coef(lm.abund)
#  (Intercept)     WatrCont 
#  3.439348672 -0.006044788
summary(lm.abund)$sigma
# [1] 1.513531
```

Quels sont les param√®tres de la distribution normale utilis√©s pour mod√©liser `\(y\)` lorsque le contenu d'eau = 300?

`$$y_i \sim N(\mu = \beta_0 + \beta_1 x_i, \sigma^2)$$`

--

`\(\mu = 3.44 + (-0.006 x 300) = 1.63\)`

`\(\sigma = 1.51\)`

---
# Pr√©diction du mod√®le

- Lorsque `\(x_i = 300\)`, `\(Y_i\)` suit une distribution normale avec `\(\mu = 1.63\)` et `\(\sigma^2 = 1.51\)`.

- Lorsque `\(x_i = 400\)`, `\(Y_i\)` suit une distribution normale avec `\(\mu = 1.02\)` et `\(\sigma^2 = 1.51\)`, etc.


&lt;br&gt;
Graphiquement, notre mod√®le ressemble √† :

--
.pull-left[
.center[
  ![:scale 100%](images/modelPredic.png)
]]

--
.pull-right[
**Probl√®mes**:
- `\(\sigma^2\)` n'est pas homog√®ne, mais `lm()` nous contraint d'utiliser toujours la m√™me valeur de `\(\sigma^2\)`,
- Les valeurs estim√©es devraient √™tre des nombres entiers.
]

---
# Donn√©es biologiques &amp; distributions

&lt;br&gt;

- Les statisticiens ont d√©velopp√© [de nombreuses lois de probabilit√© (distributions)](https://www.causascientia.org/math_stat/Dists/Compendium.pdf) correspondant √† divers types de donn√©es

- Une distribution donne la probabilit√© d'observer chaque issue possible d'une exp√©rience ou √©chantillonage (e.g. `\(abund = 8\)` Galumna)

- Les distributions peuvent √™tre **discr√®tes** (que des nombres entiers) ou **continues** (incluent aussi des fractions)

- Toutes les distributions ont des **param√®tres** qui d√©terminent leur forme (e.g. `\(\mu\)` et `\(\sigma^2\)` pour la distribution normale)

---
# Donn√©es biologiques &amp; distributions

L'abondance de *Galumna* suit une distribution discr√®te (que des nombres entiers). Pour mod√©liser les donn√©es d'abondance, la [loi de Poisson](https://fr.wikipedia.org/wiki/Loi_de_Poisson) est souvent utilis√©e:

- une distribution discr√®te avec un seul param√®tre, `\(\lambda\)` (lambda), qui d√©termine la moyenne et la variance de la distribution:

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-16-1.png" width="1080" style="display: block; margin: auto;" /&gt;

---
# Donn√©es biologiques &amp; distributions

*Galumna* semble suivre une loi de Poisson avec une faible valeur de `\(\lambda\)` :


```r
  mean(mites$Galumna)
# [1] 0.9571429
  hist(mites$Galumna)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-17-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Donn√©es biologiques &amp; distributions

Pr√©sence-absence par contre prend une autre forme :

- Inclut seulement des `0`s et des `1`s
- La loi de Poisson n'est pas appropri√©e pour cette variable


```r
  hist(mites$pa)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-18-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Donn√©es biologiques &amp; distributions

**Distribution de [Bernoulli](https://fr.wikipedia.org/wiki/Loi_de_Bernoulli)** :

- N'inclut que deux issues possibles dans son ensemble: succ√®s (`1`) ou √©chec (`0`)
- N'a qu'un param√®tre, `\(p\)`, la probabilit√© de succ√®s

&lt;br&gt;
&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-19-1.png" width="864" style="display: block; margin: auto;" /&gt;
Nous pouvons utiliser la loi de Bernoulli pour calculer la probabilit√© d'obtenir l'issue "Galumna present" (`1`) vs. "Galumna absent" (`0`)

---
# Donn√©es biologiques &amp; distributions

**[Distribution binomiale](https://fr.wikipedia.org/wiki/Loi_binomiale)** : Lorsqu'il y a plusieurs √©preuves (chacune avec un succ√®s/√©chec), la loi de Bernoulli se transforme en loi binomiale

- Inclut le param√®tre additionel `\(n\)`, le nombre d'√©preuves
- Pr√©dit la probabilit√© d'observer une certaine proportion de succ√®s, `\(p\)`, sur le nombre total d'√©preuves, `\(n\)`

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-20-1.png" width="1080" style="display: block; margin: auto;" /&gt;

---
# Donn√©es biologiques &amp; distributions

**Distribution binomiale** : utilis√©e pour mod√©liser des donn√©es lorsque le nombre de succ√®s est donn√© par un nombre entier, et lorsque le nombre d'√©preuves, `\(n\)`, est connu.

**Diff√©rence principale avec la loi de Poisson** : L'√©tendue de la loi binomiale a une limite sup√©rieure, `\(n\)`. Par cons√©quent, elle est asym√©trique et d√©cal√©e √† gauche lorsque `\(p\)` est faible, mais d√©cal√©e √† droite lorsque `\(p\)` est √©lev√©.

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-21-1.png" width="720" style="display: block; margin: auto;" /&gt;

---
# Donn√©es biologiques &amp; distributions

Retournons √† notre probl√®me pour changer la distribution de `\(Y_i\)` de normale √† Poisson :

`$$Y_i \sim Poisson(\lambda = \beta_0 + \beta_1 x_i)$$`

Le probl√®me est r√©solu!

1. `\(\lambda\)` varie avec `\(x\)` (contenu d'eau) et la variance des r√©sidus changera aussi avec `\(x\)`, et nous venons de nous d√©faire de la supposition d'homog√©n√©it√© de la variance!

2. Les valeurs estim√©es seront des nombres entiers plut√¥t que des nombres d√©cimaux;

3. Ce mod√®le ne pr√©dira jamais de valeurs n√©gatives (Poisson est toujours strictement positif).

---
# Donn√©es biologiques &amp; distributions

Ce mod√®le est **presque** un GLM de Poisson, qui ressemble √† √ßa:

.center[![:scale 90%](images/poisPred.png)]

Les probabilit√©s (en orange) sont maintenant des nombres entiers, et la variance et la moyenne de la distribution d√©clinent lorsque `\(\lambda\)` diminue avec le contenu d'eau.

---
class: inverse, center, middle

# GLM avec variable binaire

&lt;hr&gt;

---
# Variables binaires
&lt;br&gt;

Une variable r√©ponse commune dans les jeux de donn√©es en √©cologie : variable binaire, on observe un ph√©nom√®ne X ou son "absence"

- Pr√©sence/Absence d'une esp√®ce
- Pr√©sence/Absence d'une maladie
- Succ√®s/√âchec d'observer un comportement
- Survie/Mort d'un organisme

On veut d√©terminer si `\(P/A \sim Environment\)`

.comment[R√©gression logistique ou mod√®le logit]

---
# Variables binaires

Dans `R`, on code une variable binaire avec `1` et `0`:



&lt;br&gt;

.pull-left[
.right[

```
#   Site Presence
# 1    A        1
# 2    B        0
# 3    C        1
# 4    D        1
# 5    E        0
# 6    F        1
```
]]
.pull-right[
 &lt;br&gt;

 1 = Pr√©sence

 &lt;br&gt;

 0 = Absence
]

---
# Variables binaires


&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-24-1.png" width="504" style="display: block; margin: auto;" /&gt;

.alert[Avec un mod√®le lin√©aires, les r√©sidus ne seront pas distribu√©s normalement!]

---
# Variables binaires

Les valeurs pr√©dites peuvent se trouver hors de l'intervalle `[0,1]` avec `lm()`:

&lt;br&gt;

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-25-1.png" width="540" style="display: block; margin: auto;" /&gt;

---
# Distribution de probabilit√©

La distribution de Bernoulli est adapt√©e pour des variables r√©ponses binaires

&lt;br&gt;

.pull-left[.right[

`\(E(Y) = p\)`

&lt;br&gt;

`\(Var(Y) = p \times (1 - p)\)`

]]
.pull-right[

![:faic](arrow-right) **Moyenne de la distribution** .small[Probabilit√© `\(p\)` d'observer un r√©sultat]

![:faic](arrow-right) **Variance de la distribution** .small[La variance d√©cro√Æt quand `\(p\)` est proche de `0` ou `1`]
]

---
# R√©gression logistique

La fonction `glm()`!

&lt;br&gt;

```R
logit.reg &lt;- glm(formula, data, family)
```

&lt;br&gt;

Pour utiliser la bonne distribution, il faut sp√©cifier:

1. distribution de probabilit√©

--
**ET**

--
2. une [fonction de lien](https://en.wikipedia.org/wiki/Generalized_linear_model#Link_function) (il y a une fonction de lien par d√©faut pour une distribution donn√©e!) qui d√©finit aussi une relation entre la moyenne et la variance.

&lt;br&gt;

--

Dans R, cela se fait en utilisant l'argument `family` (voir `?family`) :

---
# La fonction de lien

Pour un mod√®le lin√©aire de base d'une variable r√©ponse normalement distribu√©e, l'√©quation pour la valeur attendue est :

`$$\mu = x\beta$$`

o√π

- `\(\mu\)` repr√©sente les valeurs pr√©dites par le mod√®le,
- `\(x\)` est la matrice du mod√®le (*i.e.* les variables explicatives),
- `\(\beta\)` est le vecteur des param√®tres estim√©s (*i.e.* intercept &amp; pente).


###### `\(x\beta\)` est appel√© le **pr√©dicteur lin√©aire**

---
# La fonction de lien

`\(\mu = x\beta\)` est vrai seulement pour la distribution normale

Si ce n'est pas le cas, on utilise une transformation `\(g\)` sur `\(\mu\)`

`$$g(\mu) = x\beta$$`

o√π `\(g\)` est appel√©e **fonction de lien**. Cela permet de travailler avec des distributions autres que la loi normale.

---
# La fonction de lien

Pour les donn√©es binaires, on utilise la transformation **logit** :

&lt;br&gt;

`$$g(\mu) = log\left(\frac{\mu}{1-\mu}\right)$$`

`\(\mu =\)` variables pr√©dites (probabilit√© que `\(Y = 1\)`)

--

1. `\(\frac{\mu}{1-\mu}\)` met les valeurs pr√©dites sur une √©chelle de  `0` √† `+Inf`
2. La transformer en log ce qui projette les valeurs pr√©dites sur entre`-Inf` √† `+Inf`

--

&lt;br&gt;

![:faic](arrow-right) Les valeurs pr√©dites **transform√©es** sont reli√©es **lin√©airement** au pr√©dicteur lin√©aire

---
# Exercice 1

Sp√©cifiez un mod√®le de r√©gression logistique avec le jeu de donn√©es mites.


```r
#setwd('...')
mites &lt;- read.csv("mites.csv", header = TRUE)
str(mites)

```

```
# 'data.frame':	70 obs. of  9 variables:
#  $ Galumna   : int  8 3 1 1 2 1 1 1 2 5 ...
#  $ pa        : int  1 1 1 1 1 1 1 1 1 1 ...
#  $ totalabund: int  140 268 186 286 199 209 162 126 123 166 ...
#  $ prop      : num  0.05714 0.01119 0.00538 0.0035 0.01005 ...
#  $ SubsDens  : num  39.2 55 46.1 48.2 23.6 ...
#  $ WatrCont  : num  350 435 372 360 204 ...
#  $ Substrate : Factor w/ 7 levels "Barepeat","Interface",..: 4 3 2 4 4 4 4 2 3 4 ...
#  $ Shrub     : Factor w/ 3 levels "Few","Many","None": 1 1 1 1 1 1 1 2 2 2 ...
#  $ Topo      : Factor w/ 2 levels "Blanket","Hummock": 2 2 2 2 2 2 2 1 1 2 ...
```

---
# Exercice 1

Sp√©cifiez un mod√®le de la pr√©sence et de l'absence de *Galumna sp.* en fonction du contenu en eau du sol et de la topographie.


```r
logit.reg &lt;- glm(pa ~ WatrCont + Topo, data=mites,
family = binomial(link = "logit"))
```

```r
summary(logit.reg)
```

---
# Exercice 1

.small[

```r
summary(logit.reg)
# 
# Call:
# glm(formula = pa ~ WatrCont + Topo, family = binomial(link = "logit"), 
#     data = mites)
# 
# Deviance Residuals: 
#     Min       1Q   Median       3Q      Max  
# -2.0387  -0.5589  -0.1594   0.4112   2.0252  
# 
# Coefficients:
#              Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept)  4.464402   1.670622   2.672 0.007533 ** 
# WatrCont    -0.015813   0.004535  -3.487 0.000489 ***
# TopoHummock  2.090757   0.735348   2.843 0.004466 ** 
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# 
# (Dispersion parameter for binomial family taken to be 1)
# 
#     Null deviance: 91.246  on 69  degrees of freedom
# Residual deviance: 48.762  on 67  degrees of freedom
# AIC: 54.762
# 
# Number of Fisher Scoring iterations: 6
```
]

---
# D√©fi 1 ![:cube]()

En utilisant le jeu de donn√©es 'bacteria', sp√©cifiez un mod√®le de la pr√©sence de *H. influenzae* en fonction du traitement et de la semaine de test.

Commencez avec un mod√®le satur√© et trouvez le mod√®le le plus parcimonieux.



```r
#install.packages("MASS")
library(MASS)
data(bacteria)
str(bacteria)
# 'data.frame':	220 obs. of  6 variables:
#  $ y   : Factor w/ 2 levels "n","y": 2 2 2 2 2 2 1 2 2 2 ...
#  $ ap  : Factor w/ 2 levels "a","p": 2 2 2 2 1 1 1 1 1 1 ...
#  $ hilo: Factor w/ 2 levels "hi","lo": 1 1 1 1 1 1 1 1 2 2 ...
#  $ week: int  0 2 4 11 0 2 6 11 0 2 ...
#  $ ID  : Factor w/ 50 levels "X01","X02","X03",..: 1 1 1 1 2 2 2 2 3 3 ...
#  $ trt : Factor w/ 3 levels "placebo","drug",..: 1 1 1 1 3 3 3 3 2 2 ...
```

---
# Solution ![:cube]()


```r
model.bact1 &lt;- glm(y ~ trt * week, data = bacteria, family = binomial)
```


```r
model.bact2 &lt;- glm(y ~ trt + week, data = bacteria, family = binomial)
```


```r
model.bact3 &lt;- glm(y ~ week, data = bacteria, family = binomial)
```


```r
anova(model.bact1, model.bact2, model.bact3, test = "LRT")
# Analysis of Deviance Table
# 
# Model 1: y ~ trt * week
# Model 2: y ~ trt + week
# Model 3: y ~ week
#   Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi)  
# 1       214     203.12                       
# 2       216     203.81 -2  -0.6854  0.70984  
# 3       218     210.91 -2  -7.1026  0.02869 *
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```

---
# Interpr√©ter la sortie

Regardez √† nouveau les coefficients du mod√®le `logit.reg` :


```r
summary(logit.reg)$coefficients
#                Estimate  Std. Error   z value     Pr(&gt;|z|)
# (Intercept)  4.46440199 1.670622482  2.672299 0.0075333598
# WatrCont    -0.01581255 0.004535069 -3.486728 0.0004889684
# TopoHummock  2.09075654 0.735348234  2.843220 0.0044660283
```

La sortie indique que le contenu d'eau et la topographie sont significatifs

.comment[Mais comment interpr√®te-on les coefficients de la pente?]

---
# Interpr√©ter la sortie

Rappelez-vous que nous avons utilis√© une transformation logit!

Pour bien interpr√©ter les coefficients du mod√®le, il faut les utiliser avec la fonction de lien inverse ( `\(g^{-1}\)` ):

`$$g^{-1}(\beta_0 + \beta_1x)$$`


&lt;!-- La fonction exponentielle pour obtenir les cotes : `\(e^x\)` --&gt;

Dans notre exemple, la fonction `\(logit\)` inverse est utiliser pour obtenir les probabilit√©s :

`$$logit^{-1} = \frac{1}{1 + e^{-(\beta_0 + \beta_1 WatrCont + \beta_2 TopoHummock)}}$$`


---
# Pouvoir pr√©dictif et ajustement du mod√®le
&lt;br&gt;

Le [pseudo-R¬≤](https://stats.idre.ucla.edu/other/mult-pkg/faq/general/faq-what-are-pseudo-r-squareds/), un concept analogue au `\(R^2\)` pour les mod√®les estim√©s par maximisation de la vraisemblance:

`$$\text{pseudo-R}^2 = \frac{\text{d√©viance nulle - d√©viance r√©siduelle}}{\text{d√©viance nulle}}$$`

&lt;br&gt;

`\(\text{pseudo-R}^2 = \text{variance expliqu√©e par le mod√®le}\)`

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Comparer la d√©viance du mod√®le (d√©viance r√©siduelle) √† la d√©viance d'un mod√®le nul (d√©viance nulle)

Le **mod√®le nul** est un mod√®le sans variables explicatives, simplement l'ordonn√©e √† l'origine

```R
null.model &lt;- glm(Response.variable ~ 1, family = binomial)
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :


```r
objects(logit.reg)
#  [1] "aic"               "boundary"          "call"             
#  [4] "coefficients"      "contrasts"         "control"          
#  [7] "converged"         "data"              "deviance"         
# [10] "df.null"           "df.residual"       "effects"          
# [13] "family"            "fitted.values"     "formula"          
# [16] "iter"              "linear.predictors" "method"           
# [19] "model"             "null.deviance"     "offset"           
# [22] "prior.weights"     "qr"                "R"                
# [25] "rank"              "residuals"         "terms"            
# [28] "weights"           "xlevels"           "y"
```

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Dans R, nous pouvons extraire les d√©viances r√©siduelles et nulles directement √† partir de l'objet glm :


```r
pseudoR2 &lt;- (logit.reg$null.deviance - logit.reg$deviance) / logit.reg$null.deviance
pseudoR2
# [1] 0.4655937
```

.comment[Ainsi, le mod√®le explique 46.6% de la variabilit√© des donn√©es]

---
# Pouvoir pr√©dictif et ajustement du mod√®le

Nouvelle statistique - **coefficient de discrimination (D)** √©value le pouvoir pr√©dictif d'une r√©gression logistique

- Mesure √† quel point la r√©gression logistique est capable de bien classifier un r√©sultat en succ√®s ou √©chec

Pour √©valuer l'ajustement du mod√®le, les graphiques de diagnostique ne sont pas utiles, il vaut mieux utiliser le [test de Hosmer-Lemeshow](https://en.wikipedia.org/wiki/Hosmer%E2%80%93Lemeshow_test):

- Compare le nombre de r√©sultats obtenus et attendus
- Similaire √† un test de `\(Chi^2\)`

---
# Exercice 2

La fonction R `PseudoR2` dans le package` DescTools` permet de calculer plusieurs Pseudo R2. En sp√©cifiant `which = all`, calculez toutes les statistiques en m√™me temps.



```r
library(DescTools)
fit &lt;- PseudoR2(logit.reg, which = "all")
fit
#        McFadden     McFaddenAdj        CoxSnell      Nagelkerke   AldrichNelson 
#       0.4655937       0.3998373       0.4549662       0.6245898       0.3776866 
# VeallZimmermann           Efron McKelveyZavoina            Tjur             AIC 
#       0.6674318       0.5024101       0.7064093       0.5114661      54.7623962 
#             BIC          logLik         logLik0              G2 
#      61.5078819     -24.3811981     -45.6229593      42.4835224
```

---
# Exercice 2: Faites le test de Hosmer-Lemeshow


```r
library(vcdExtra)
HLtest(logit.reg)
# Hosmer and Lemeshow Goodness-of-Fit Test 
# 
# Call:
# glm(formula = mites$pa ~ mites$WatrCont + mites$Topo, family = binomial(link = "logit"))
#  ChiSquare df   P_value
#   3.421693  8 0.9051814
```

.comment[Une valeur non significative indique un ajustement ad√©quat!]


---
# D√©fi 2 ![:cube]()
&lt;br&gt;


1. En utilisant le mod√®le cr√©√© avec le jeu de donn√©es 'bacteria', √©valuez le pouvoir pr√©dictif et l'ajustement de ce mod√®le.

2. Comment faire pour am√©liorer le pouvoir explicatif du mod√®le?

---
# Solution ![:cube]()

1 :

```r
null.d &lt;- model.bact2$null.deviance
resid.d &lt;- model.bact2$deviance
bact.pseudoR2 &lt;- (null.d - resid.d) / null.d
HLtest(model.bact2)
```

2 : Ajouter des variables explicatives pertinentes pourrait certainement augmenter le pouvoir explicatif du mod√®le.

---
# GLM et donn√©es de proportions

Parfois, les donn√©es de proportions sont plus similaires √† un r√©gression logistique que ce que vous pensez...

Si on mesure un nombre d'occurences et qu'on conna√Æt la taille d'√©chantillon, on obtient des donn√©es de proportions!

Supposons qu'on mesure la pr√©valence d'une maladie sur dix cerfs dans 10 populations diff√©rentes :

.pull-left[

`$$\frac{x\,\, \text{infected deer}}{10\,\,\text{deer}}$$`

]

.pull-right[
![:faic](arrow-right) toujours entre `0` et `1`!
]

---
# Exercice 3

Dans R, on doit sp√©cifier le nombre de fois qu'un √©v√©nement s'est produit et le nombre de fois qu'un √©v√©nement ne s'est pas produit:


```r
prop.reg &lt;- glm(cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, data = mites, family = binomial)
```

```r
summary(prop.reg)
```

---
# Exercice 3

.small[

```r
summary(prop.reg)
# 
# Call:
# glm(formula = cbind(Galumna, totalabund - Galumna) ~ Topo + WatrCont, 
#     family = binomial, data = mites)
# 
# Deviance Residuals: 
#     Min       1Q   Median       3Q      Max  
# -1.4808  -0.9699  -0.6327  -0.1798   4.1688  
# 
# Coefficients:
#              Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept) -3.288925   0.422109  -7.792 6.61e-15 ***
# TopoHummock  0.578332   0.274928   2.104   0.0354 *  
# WatrCont    -0.005886   0.001086  -5.420 5.97e-08 ***
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# 
# (Dispersion parameter for binomial family taken to be 1)
# 
#     Null deviance: 140.702  on 69  degrees of freedom
# Residual deviance:  85.905  on 67  degrees of freedom
# AIC: 158.66
# 
# Number of Fisher Scoring iterations: 5
```
]

---
# Exercice 3

On peut coder le mod√®le directement avec les proportions:


```r
prop.reg2 &lt;- glm(prop ~ Topo + WatrCont, data = mites,
                 family = binomial, weights = totalabund)
```

---
class: inverse, center, middle

# GLM avec des donn√©es d'abondance

&lt;hr&gt;

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Importez le jeu de donn√©es `faramea.csv` dans R



```r
faramea &lt;- read.csv('faramea.csv', header = TRUE)
```

Le nombre d'arbres de l'esp√®ce *Faramea occidentalis* a √©t√© compt√© dans 43 quadrats sur l'√Æle de Barro Colorado (Panama). Des donn√©es environnementales, comme l'√©l√©vation et la pr√©cipitation ont aussi √©t√© mesur√©es.

Examinons maintenant √† quoi ressemble la distribution du nombre d'arbres par transect.

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-47-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Mod√©liser des donn√©es d'abondance

.large[Que sont des donn√©es d'abondance?]

Les donn√©es d'abondance sont charact√©ris√©es par:

- des valeurs positives : on ne peut pas compter -7 individus
- des valeurs enti√®res : on ne peut pas compter 7.56 individus
- une plus grande variance pour les fortes valeurs

---
# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-48-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# Mod√©liser des donn√©es d'abondance

.large[Comment mod√©liser des donn√©es d'abondance?]

L'√©l√©vation influence-t-elle l'abondance de *F. occidentalis*?

La **distribution de Poisson** semble √™tre le choix parfait pour mod√©liser ces donn√©es, ainsi des **GLMs Poisson** sont g√©n√©ralement une bonne fa√ßon pour commencer √† mod√©liser des donnes d'abondance.

---
# La distribution de Poisson

La distribution de poisson, qui sp√©cifie la probabilit√© d'une variable al√©atoire discr√®te Y, est donn√©es par :

`$$f(y, \,\mu)\, =\, Pr(Y = y)\, =\, \frac{\mu^y \times e^{-\mu}}{y!}$$`

`$$E(Y)\, =\, Var(Y)\, =\, \mu$$`

**Propri√©t√©s** :

- `\(\mu\)` est le param√®tre de la distribution de Poisson
- sp√©cifie la probabilit√© pour des valeurs enti√®res uniquement
- la probabilit√© pour des valeurs n√©gatives est nulle ( `\(P(Y&lt;0) = 0\)`)
- moyenne = variance (permet l'h√©t√©rog√©n√©it√©)

---
# Que se cache-t-il derri√®re un GLM Poisson?

Un GLM Poisson va mod√©liser la valeur de `\(\mu\)` en fonction de diff√©rentes variables explicatives.

.center[**Trois √©tapes**]

**√âtape 1.** On suppose que `\(Y_i\)` suit une distribution de Poisson de moyenne et variance `\(\mu_i\)`

`$$Y_i = Poisson(\mu_i)$$`

`$$E(Y_i) = Var(Y_i) = \mu_i$$`

`$$f(y_i, \, \mu_i) = \frac{\mu^{y_i}_i \times e^{-\mu_i}}{y!}$$`

`\(\mu_i\)` correspond au nombre attendu d'individus

---
# Que se cache-t-il derri√®re un GLM Poisson?

**√âtape 2.** On sp√©cifie le pr√©dicteur lin√©aire comme dans un mod√®le lin√©aire

`$$\underbrace{\alpha}_\text{One intercept} + \underbrace{\beta}_\text{slope of 'Elevation'} \times \text{Elevation}_i$$`

**√âtape 3.** La fonction de lien entre la moyenne de `\(Y_i\)` et la partie syst√©matique est un log

`$$log(\mu_i) = \alpha + \beta \times \text{Elevation}_i$$`

.center[ou]

`$$\mu_i = e^{ \alpha + \beta \times \text{Elevation}_i}$$`

---
# Ajuster un GLM Poisson sous R

La fonction `glm()` permet de sp√©cifier un GLM Poisson


```r
glm.poisson = glm(Faramea.occidentalis~Elevation, data=faramea, family=poisson)
```

L'argument `family` permet de sp√©cifier le type de distribution et la fonction de lien (log)

&lt;br&gt;

Tout comme avec `lm()`, vous pouvez acc√©der au r√©sum√© du mod√®le √† l'aide de la fonction `summary()`


```r
summary(glm.poisson)
```

---
# R√©sum√© du mod√®le

.pull-left2[
.small[

```r
summary(glm.poisson)
# 
# Call:
# glm(formula = Faramea.occidentalis ~ Elevation, family = poisson, 
#     data = faramea)
# 
# Deviance Residuals: 
#     Min       1Q   Median       3Q      Max  
# -3.3319  -2.7509  -1.5451   0.1139  11.3995  
# 
# Coefficients:
#               Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept)  1.7687001  0.1099136  16.092  &lt; 2e-16 ***
# Elevation   -0.0027375  0.0006436  -4.253 2.11e-05 ***
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# 
# (Dispersion parameter for poisson family taken to be 1)
# 
#     Null deviance: 414.81  on 42  degrees of freedom
# Residual deviance: 388.12  on 41  degrees of freedom
# AIC: 462.01
# 
# Number of Fisher Scoring iterations: 10
```
]]

.pull-right2[
Estim√©s :

Intercept = `\(\alpha\)`

√âlevation = `\(\beta\)`

]

--

.pull-right2[
&lt;br&gt;
Qu'en est-il de `Null deviance` et `Residual deviance`?!
]


---
# Estimation des param√®tres

Dans notre mod√®le, les param√®tres √† estimer sont l'ordonn√©e √† l'origine ( `\(\alpha\)` ) et le coefficient de r√©gression de l'√©levation ( `\(\beta\)` )


`$$log(\mu_i) = 1.769 - 0.0027 \times \text{√âlevation}_i$$`

.center[ou]

`$$\mu_i = e^{1.769 - 0.0027 \times \text{√âlevation}_i}$$`


---
# La d√©viance

Rappelez vous que pour estimer les param√®tres inconnus, l'estimation par maximum de vraisemblance est utilis√©e

La d√©viance r√©siduelle est approximativement la diff√©rence entre la vraisemblance d'un mod√®le satur√© (n param√®tres pour chaque observation) et le mod√®le complet (p param√®tres):

`$$\text{Res dev} = 2 \, log(L(y;\,y)) - 2 \, log(L(y;\, \mu))$$`

Dans un GLM Poisson, la d√©viance r√©siduelle doit √™tre √©gale au nombre de degr√©s de libert√© r√©siduels

.center[.alert[388.12 &gt;&gt; 41]]

---
# La surdispersion

Quand la d√©viance r√©siduelle est sup√©rieure au nombre de degr√©s de libert√© r√©siduels, le mod√®le est **surdispers√©**

`$$\phi ~ = ~\frac{\text{D√©viance r√©siduelle}}{\text{Degr√©s de libert√© r√©siduels}}$$`

Se produit lorsque la variance dans les donn√©es est plus grande que la moyenne. Dans ce cas la distribution de Poisson n'est plus appropri√©e (beaucoup de z√©ros, covariables manquantes, etc.)

.center[.large[**Solutions**]]

.pull-left[
1: Corriger la surdispersion en utilisant en **GLM quasi-Poisson**
]

.pull-right[
2: Choisir une autre distribution : **la [negative binomial](https://fr.wikipedia.org/wiki/Loi_binomiale_n%C3%A9gative)**
]

---
# GLM Quasi-Poisson

La variance du mod√®le tient compte de la **surdispersion** en ajoutant le param√®tre de surdispersion:

`$$E(Y_i) = \mu_i$$`

`$$Var(Y_I) = \phi \times \mu_i$$`

le **pr√©dicteur lin√©aire** et la **fonction de lien** restent les m√™me

`\(\phi\)` est le param√®tre de dispersion. Il sera estim√© avant les param√®tres. Corriger pour la surdispersion ne va pas affecter l'estimation des param√®tres, mais leur **significativit√©**. En effet, les √©carts-types des param√®tres seront multipli√©s par `\(\sqrt{\phi}\)`.

.alert[Certaines p-values marginalement significatives peuvent devenir non significatives!]

---
# Ajuster un GLM quasi-Poisson sous R

Cr√©ez un nouveau GLM √† l'aide de la famille 'quasipoisson' ou actualisez le mod√®le pr√©c√©dent:


```r
glm.quasipoisson = glm(Faramea.occidentalis ~ Elevation, data = faramea,
                       family=quasipoisson)
glm.quasipoisson = update(glm.poisson, family = quasipoisson)
```

---
# Ajuster un GLM quasi-Poisson sous R

.pull-left2[
.small[

```r
summary(glm.quasipoisson)
# 
# Call:
# glm(formula = Faramea.occidentalis ~ Elevation, family = quasipoisson, 
#     data = faramea)
# 
# Deviance Residuals: 
#     Min       1Q   Median       3Q      Max  
# -3.3319  -2.7509  -1.5451   0.1139  11.3995  
# 
# Coefficients:
#              Estimate Std. Error t value Pr(&gt;|t|)    
# (Intercept)  1.768700   0.439233   4.027 0.000238 ***
# Elevation   -0.002738   0.002572  -1.064 0.293391    
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# 
# (Dispersion parameter for quasipoisson family taken to be 15.96936)
# 
#     Null deviance: 414.81  on 42  degrees of freedom
# Residual deviance: 388.12  on 41  degrees of freedom
# AIC: NA
# 
# Number of Fisher Scoring iterations: 10
```
]]
.pull-right2[
**M√™mes estim√©s mais**

.small[Les √©carts-types des param√®tres sont multipli√©s par]

`$$\sqrt{\phi} = 4$$`

`0.0006436 * 4 = 0.00257`

&lt;- `\(\phi\)`

&lt;br&gt;

&lt;- .small[Pas d'AIC!]
]

---
# Ajuster un GLM quasi-Poisson sous R

Testons l'effet de l'√©l√©vation par une analyse de d√©viance :


```r
null.model &lt;- glm(Faramea.occidentalis ~ 1, data = faramea,
                  family = quasipoisson)
anova(null.model, glm.quasipoisson, test = "Chisq")
# Analysis of Deviance Table
# 
# Model 1: Faramea.occidentalis ~ 1
# Model 2: Faramea.occidentalis ~ Elevation
#   Resid. Df Resid. Dev Df Deviance Pr(&gt;Chi)
# 1        42     414.81                     
# 2        41     388.12  1   26.686   0.1961
```

---
# Param√®tre de dispersion

.center[![:scale 80%](images/dispParam.png)]

---
# GLM binomiale n√©gative

Une distribution binomiale n√©gative est favoris√©e quand la surdispersion est forte

- La distribution a **deux param√®tres** `\(\mu\)` and `\(k\)`. `\(k\)` contr√¥le pour la dispersion (plus la dispersion est forte, plus `\(k\)` est petit)
- C'est une combinaison de deux distributions (**Poisson** et **gamma**)
- Les `\(Y_i\)` suivent une distribution de Poisson dont la moyenne `\(\mu\)` suit une distribution Gamma!

`$$E(Y_i) = \mu_i$$`

`$$Var(Y_i) = \mu_i + \frac{\mu^2_i}{k}$$`


---
# Ajuster une binomiale n√©gative sous R

NB La distribution binomiale n'est pas dans la fonction `glm()` donc il faut installer et charger la paquet `MASS`

```r
install.packages('MASS')
```


```r
glm.negbin = glm.nb(Faramea.occidentalis ~ Elevation, data = faramea)
```

```r
summary(glm.negbin)
```

---
# Ajuster une binomiale n√©gative sous R

.pull-left2[
.small[

```
# 
# Call:
# glm.nb(formula = Faramea.occidentalis ~ Elevation, data = faramea, 
#     init.theta = 0.2593107955, link = log)
# 
# Deviance Residuals: 
#      Min        1Q    Median        3Q       Max  
# -1.36748  -1.17564  -0.51338  -0.05226   2.25716  
# 
# Coefficients:
#              Estimate Std. Error z value Pr(&gt;|z|)    
# (Intercept)  2.369226   0.473841    5.00 5.73e-07 ***
# Elevation   -0.007038   0.002496   -2.82  0.00481 ** 
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
# 
# (Dispersion parameter for Negative Binomial(0.2593) family taken to be 1)
# 
#     Null deviance: 41.974  on 42  degrees of freedom
# Residual deviance: 36.343  on 41  degrees of freedom
# AIC: 182.51
# 
# Number of Fisher Scoring iterations: 1
# 
# 
#               Theta:  0.2593 
#           Std. Err.:  0.0755 
# 
#  2 x log-likelihood:  -176.5090
```
]]
.pull-right2[

&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;&lt;br&gt;
`theta` `\(= k\)`
]

---
# Repr√©senter le mod√®le final

**√âtape 1** Repr√©senter les donn√©es et utiliser les estimations des param√®tres pour repr√©senter le mod√®le

`$$\mu_i = e^{2.369 - 0.007 \times Elevation_i}$$`

Utilisez `summary()` pour obtenir les param√®tres

```r
summary(glm.negbin)$coefficients[1, 1]
summary(glm.negbin)$coefficients[2, 1]
```

---
# Repr√©senter le mod√®le final

**√âtape 2** Utilisez les √©carts-types pour construire l'intervalle de confiance

```r
summary(glm.negbin)$coefficients[1, 2]
summary(glm.negbin)$coefficients[2, 2]
```

`$$\text{Limite sup} = e^{[\alpha - 1.96 \times SE_{\alpha}] + [\beta - 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$`

`$$\text{Limit inf} = e^{[\alpha + 1.96 \times SE_{\alpha}] + [\beta + 1.96 \times SE_{\beta}] \times \text{√âlevation}_i}$$`

---
# Repr√©senter le mod√®le final

.small[

```r
pp &lt;- predict(glm.negbin, newdata = data.frame(Elevation = 1:800), se.fit = TRUE)
linkinv &lt;- family(glm.negbin)$linkinv ## inverse-link function
pframe$pred0 &lt;- pp$fit
pframe$pred &lt;- linkinv(pp$fit)
sc &lt;- abs(qnorm((1-0.95)/2))  ## Normal approx. to likelihood
pframe &lt;- transform(pframe, lwr = linkinv(pred0-sc*pp$se.fit), upr = linkinv(pred0+sc*pp$se.fit))
# sinon, utiiser predic() avec type="response"

plot(faramea$Elevation, faramea$Faramea.occidentalis, ylab = 'Number of F. occidentalis', xlab = 'Elevation(m)')
lines(pframe$pred, lwd = 2)
lines(pframe$upr, col = 2, lty = 3, lwd = 2)
lines(pframe$lwr, col = 2, lty = 3, lwd = 2)
```
]

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-58-1.png" width="432" style="display: block; margin: auto;" /&gt;

---
# D√©fi 3 ![:cube]()


Utilisez le jeu de donn√©es `mites`! Mod√©lisez l'abondance de l'esp√®ce *Galumna* en fonction des caract√©ristiques du substrat (son contenu en eau `WatrCont` et sa densit√© `SubsDens`)

- Faut-il contr√¥ler pour la surdispersion?
- Quelles variables explicatives ont un effet significatif?
- Selectionnez le meilleur mod√®le!



```r
mites &lt;- read.csv("mites.csv", header = TRUE)
```

---
# D√©fi 3 : conseils ![:cube]()

S√©lection pas √† pas en retirant √† chaque fois une variable et en comparant le mod√®le emboit√© au mod√®le complet :

```r
drop1(MyGLM, test = "Chi")
```

Sp√©cifiez un mod√®le embo√Æt√© manuellement, appelez le `MyGLM2`, et utilisez la fonction anova():

```r
anova(MyGLM, MyGLM2, test = "Chi")
```

---
# D√©fi 3 : solution ![:cube]()

.small[

```r
# GLM Poisson
glm.p = glm(Galumna~WatrCont+SubsDens, data=mites, family=poisson)
# GLM quasi-Poisson
glm.qp = update(glm.p,family=quasipoisson)
# s√©lection du mod√®le
drop1(glm.qp, test = "Chi")
# Single term deletions
# 
# Model:
# Galumna ~ WatrCont + SubsDens
#          Df Deviance scaled dev.  Pr(&gt;Chi)    
# &lt;none&gt;        101.49                          
# WatrCont  1   168.10      31.711 1.789e-08 ***
# SubsDens  1   108.05       3.125   0.07708 .  
# ---
# Signif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1
```
```r
# ou
glm.qp2 = glm(Galumna~WatrCont, data=mites, family=quasipoisson)
anova(glm.qp2, glm.qp, test="Chisq")
```
]


---
# D√©fi 3 : solution ![:cube]()

&lt;br&gt;

.center[
&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-62-1.png" width="432" style="display: block; margin: auto;" /&gt;
]


---
# Autres distributions
&lt;br&gt;

- **Transformation logit des donn√©es** souvent utilis√©e avec `lm()` pour les pourcentages et les proportions quand la distribution binomiale n'est pas appropri√©e. Quand non selectionn√© √† partir de quantit√©s fix√©es (e.g. pourcentage de couverture, grades scolaires, etc).
- **Distribution log-normal dans un glm**, √©vite d'avoir √† log-transformer les donn√©es.
- **Distribution Gamma**. Similaire √† une log-normal, plus flexible.
- **Distribution tweedie**. Famille de distributions flexible. Utile pour des donn√©es avec un m√©lange de 0 et de valeurs positives (pas forc√©ment des comptes).
- **Poisson ou negative binomiale √† inflation de z√©ro**. Quand les donn√©es comprennent un nombre excessif de z√©ros, venant d'un processus diff√©rent de celui qui g√©n√®re les comptes.

---
class: inverse, center, middle

# GLMMs

&lt;hr&gt;
&lt;br&gt;

---
# R√©vision: Mod√®les Lin√©aires Mixtes

**Rappel de l'atelier LMM**:

- Structure dans le jeu de donn√©es ou corr√©lation entre les observations peut entra√Æner une **d√©pendance entre les observations** √©chantillonn√©s √† partir des m√™me sites ou points dans le temps
- On en tient compte en incluant des **termes d'effet al√©atoire**

**Effets al√©atoires**:

- Un √©chantillon de la population, i.e. les sujets que vous avez √©chantillonn√©s par hasard
- Explique la variation de la variable r√©ponse

**Effets fixes**:

- Reproductible, i.e serait le m√™me dans toutes les √©tudes
- Explique la moyenne de la variable r√©ponse

---
# R√©vision: Mod√®les Lin√©aires Mixtes

.pull-left[
**"Shrinkage estimates"**

- Les effets al√©atoires sont souvent appel√©s des **estimations de r√©tr√©cissement** parce qu'ils repr√©sentent une moyenne pond√©r√©e des donn√©es et de l'ajustement global (effet fixe)
- La baisse des coeff. vers l'ajustement global est plus s√©v√®re si la variabilit√© intra-groupe est grande par rapport √† la variabilit√© inter-groupe
]

.pull-right[
&lt;br&gt;
![](images/lmm.png)
]


---
# Mod√®les Lin√©aires G√©n√©ralis√©s Mixtes (GLMMs)

Extension des GLMs tenant compte de structures suppl√©mentaires dans les donn√©es

Suivre les √©tapes similaires √† celles introduites lors de l'atelier sur les LMMs:

1. LMMs incorporent les effets al√©atoires
2. GLMs peuvent g√©rer des donn√©es non-normales (en laissant les erreurs prendre diff√©rentes familles de distribution - e.g Poisson ou binomial n√©gatif)

---
# Comment mod√©liser un GLM sous R

Chargez les donn√©es `Arabidopsis` `banta_totalfruits.csv` dans R.



```r
dat.tf &lt;- read.csv("banta_totalfruits.csv")
```
```r
# popu facteur avec un niveau pour chaque population
# gen facteur avec un niveau pour chaque g√©notype
# nutrient facteur avec niveau bas (valeur = 1) ou haut (valeur = 8)
# amd facteur pr√©cisant l'absence ou la pr√©sence d'herbivorie
# total.fruits nombre entier indiquant le nombre de fruits par plante
```

L'effet de la disponibilit√© de nutriments et d'herbivorie (**effets fixes**) sur la production de fruits d'*Arabidopsis thaliana* (arabette des dames) a √©t√© √©valu√© en mesurant 625 plantes √† travers neuf populations diff√©rentes, constitu√©es chacune de 2 √† 3 g√©notypes (**effets al√©atoires**)


---
# Choisir la distribution des erreurs

La variable r√©ponse constitue des donn√©es d'abondance, donc nous devons choisir une **distribution de Poisson** (i.e variance √©gale √† la moyenne)

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-64-1.png" width="432" style="display: block; margin: auto;" /&gt;
Cependant, comme nous le verrons, la variance de chaque groupe augmente beaucoup plus rapidement que pr√©vu...

---
# Exploration de la variance

Pour illustrer l'h√©t√©rog√©n√©it√© de la variance, nous allons d'abord cr√©er des bo√Ætes √† moustaches (boxplots) de la variable r√©ponse par rapport aux diff√©rents facteurs environnementaux

Cr√©ons de nouvelles variables qui repr√©sentent toutes les combinaisons de **nutriments** x **herbivorie** x **facteur al√©atoire**


```r
dat.tf &lt;- within(dat.tf,
{
  # g√©notype x nutriment x herbivorie
  gna &lt;- interaction(gen,nutrient,amd)
  gna &lt;- reorder(gna, total.fruits, mean)
  # population x nutriment x herbivorie
  pna &lt;- interaction(popu,nutrient,amd)
  pna &lt;- reorder(pna, total.fruits, mean)
})
```

---
# Exploration de la variance

.small[

```r
# Boxplot du total des fruits vs interaction g√©notype x nutriment x herbivorie
library(ggplot2)
ggplot(data = dat.tf, aes(factor(x = gna),y = log(total.fruits + 1))) +
  geom_boxplot(colour = "skyblue2", outlier.shape = 21,
  outlier.colour = "skyblue2") +
  theme_bw() + theme(axis.text.x=element_blank()) +
  stat_summary(fun.y=mean, geom="point", colour = "red")
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-66-1.png" width="576" style="display: block; margin: auto;" /&gt;
]

.comment[De m√™me, la bo√Æte √† moustaches total des fruits vs population x nutriments x herbivorie montre une grande quantit√© d'h√©t√©rog√©n√©it√© entre les populations.]


---
# Choisir la distribution des erreurs

Comme nous venons de le voir, il existe une importante h√©t√©rog√©n√©it√© parmi la variance de chaque groupe, m√™me lorsque la variable r√©ponse est transform√©e

Si nous repr√©sentons graphiquement les **√©carts vs moyennes par groupes** (g√©notypes x nutriment x herbivorie), on voit que la distribution de Poisson est la moins appropri√©e (i.e. √©cart augmentent beaucoup plus vite que la moyenne)

.small[.pull-left[
![](images/errDist.png)
]
.pull-right[

&lt;font color="blue"&gt;NB = negative binomial&lt;/font&gt;

&lt;br&gt;

&lt;font color="red"&gt;QP = quasi-Poisson&lt;/font&gt;

&lt;br&gt;
&lt;font color="LightBlue"&gt;loess = Locally weighted regression smoothing&lt;/font&gt;
]]


---
# GLMM Poisson

Compte tenu de la relation moyenne-variance, nous avons besoin d'un mod√®le avec surdispersion.

- Mais commen√ßons avec un mod√®le de Poisson :

Pour lancer un GLMM dans R, nous faisons appel √† la fonction `glmer()`, du paquet lme4


```r
library(lme4)
mp1 &lt;- glmer(total.fruits ~ nutrient*amd + rack + status +
             (1|popu)+
             (1|gen),
             data = dat.tf, family = "poisson")
```

**Effets al√©atoires** : `(1|popu)` contient un intercept al√©atoire partag√© par les mesures qui ont la m√™me valeur pour `popu`

---
# V√©rification de la surdispersion

Nous pouvons v√©rifier la surdispersion en utilisant la fonction `overdisp_fun()` (Bolker *et al*. 2011) qui divise la d√©viance des r√©sidus (r√©sidus de Pearson) par les degr√©s de libert√© des r√©sidus et teste si le rapport est plus grand que 1


```r
# T√©l√©chargez le code glmm_funs.R de la page wiki et sourcez le pour ex√©cuter la fonction dans R
source(file="data/glmm_funs.R")
# Surdispersion?
overdisp_fun(mp1)
#       chisq       ratio           p        logp 
# 15755.86833    25.57771     0.00000 -6578.47027
```

- Ratio est significativement `\(&gt;&gt;\)` 1
- Comme on s'y attendait, nous devons mod√©liser une distribution diff√©rente o√π la variance augmente plus rapidement que la moyenne

---
# GLMM binomiale negative .small[(Poisson-gamma)]

La distribution binomiale n√©gative satisfait la supposition que la **variance est proportionnelle au carr√© de la moyenne**


```r
mnb1 &lt;- glmer.nb(total.fruits ~ nutrient*amd + rack + status +
                 (1|popu)+
                 (1|gen),
                 data=dat.tf, control=glmerControl(optimizer="bobyqa"))
# Control sp√©cifie la fa√ßon dont nous optimisons les valeurs des param√®tres
```

.pull-left[
```r
# Surdispersion?
overdisp_fun(mnb1)
```
]
.pull-right[
![:faic](arrow-left).small[.alert[Le rapport est maintenant beaucoup plus pr√®s de 1 mais la valeur de p &lt; 0.05]]
]

---
# GLMM Poisson-lognormal

- Un autre option est la distribution **Poisson-lognormal**.
- Cela peut √™tre r√©alis√© simplement en pla√ßant un effet al√©atoire de niveau d'observation dans la formule.
.small[

```r
mpl1 &lt;- glmer(total.fruits ~ nutrient*amd + rack + status +
              (1|X) +
              (1|popu)+
              (1|gen),
data=dat.tf, family="poisson",
control = glmerControl(optimizer = "bobyqa"))
```

`(1|X)` traite de la surdispersion en ajoutant des **effets al√©atoires au niveau de l'observation**


```r
overdisp_fun(mpl1)
#         chisq         ratio             p          logp 
#  1.775363e+02  2.886768e-01  1.000000e+00 -3.755952e-73
```

.alert[Rapport maintenant conforme avec notre crit√®re]
]

---
# GLMM Poisson-lognormal

**Repr√©sentation graphique des param√®tres du mod√®le**: Une repr√©sentation graphique des param√®tres du mod√®le peut √™tre obtenue en utilisant la fonction `coefplot2()`du paquet `coefplot2`:

--

.alert[![:faic](warning) Ce paquet n'est pas sur le CRAN! On utilise le package remotes pour l'installer depuis GitHub]


```r
if (!require("coefplot2"))
  remotes::install_github("palday/coefplot2", subdir = "pkg")
library(coefplot2)
```

---
# GLMM Poisson-lognormal


.pull-left[

```r
# Param√®tres de la variance
coefplot2(mpl1, ptype = "vcov", intercept = TRUE)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-72-1.png" width="432" style="display: block; margin: auto;" /&gt;
]
.pull-right[

```r
# Effets fixes
coefplot2(mpl1, intercept = TRUE)
```

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-73-1.png" width="432" style="display: block; margin: auto;" /&gt;
]

.alert[Note]: barres d'erreur visibles seulement pour les effets fixes parce que glmer ne nous donne pas d'informations sur l'incertitude des effets al√©atoires.

---
# Visualisation des effets al√©atoires

Vous pouvez aussi extraire les effets al√©atoires en utilisant la fonction `ranef()` et les tracer en utilisant un `dotplot()` du paquet `lattice`

Il y a une variabilit√© r√©gionale parmi les populations :

- Les populations espagnoles (SP) ont des valeurs plus √©lev√©es que les populations su√©doises (SW) et n√©erlandaises (NL)

La diff√©rence entre les g√©notypes semble largement induite par g√©notype 34

```r
library(gridExtra)
library(lattice)
# dotplot code
pp &lt;- list(layout.widths=list(left.padding=0, right.padding=0),
           layout.heights=list(top.padding=0, bottom.padding=0))
r2 &lt;- ranef(mpl1, condVar = TRUE)
d2 &lt;- dotplot(r2, par.settings = pp)
grid.arrange(d2$gen, d2$popu, nrow = 1)
```

---
# Visualisation des effets al√©atoires

&lt;br&gt;

&lt;img src="workshop07-fr_files/figure-html/unnamed-chunk-74-1.png" width="648" style="display: block; margin: auto;" /&gt;


---
# S√©lection du mod√®le

Les m√™me m√©thodes peuvent √™tre utilis√©es avec un glmm ou lmm pour choisir entre des mod√®les avec diff√©rents intercepts al√©atoires et/ou des pentes al√©atoires et pour choisir les effets fixes √† conserver dans le mod√®le final.

- une **approche de la th√©orie de l'information** (e.g., AICc - Atelier 5)
- une **approche fr√©quentiste** (o√π l'importance de chaque terme est √©valu√©e en utilisant `anova()` et le test de rapport de vraisemblance; LRT)


---
# S√©lection du mod√®le

Nous d√©rivons d'abord les mod√®les potentiels et les comparons en utilisant AICc.comment[*]:


```r
mpl2 &lt;- update(mpl1, . ~ . - rack) # mod√®le sans rack
mpl3 &lt;- update(mpl1, . ~ . - status) # mod√®le sans status
mpl4 &lt;- update(mpl1, . ~ . - amd:nutrient) # mod√®le sans interaction amd:nutrient
bbmle::ICtab(mpl1, mpl2, mpl3, mpl4, type = c("AICc"))
#      dAICc df
# mpl1  0.0  10
# mpl4  1.4  9 
# mpl3  1.5  8 
# mpl2 55.0  9
```

.comment[*NB: Nous ne couvrons pas tous les mod√®les possibles ci-dessus, cependant, l'interaction `amd:nutriments` ne peut √™tre √©valu√©e que si amd et nutriments sont pr√©sents dans le mod√®le.
]


---
# S√©lection du mod√®le

Nous pouvons aussi utiliser les fonctions `drop1()` et `dfun()` pour √©valuer nos effets fixes (`dfun()` convertit les valeurs AIC retourn√©es par `drop1()` en valeurs `\(\Delta\)`AIC)

.small[

```r
dd_LRT &lt;- drop1(mpl1,test="Chisq")
(dd_AIC &lt;- dfun(drop1(mpl1)))
# Single term deletions
# 
# Model:
# total.fruits ~ nutrient * amd + rack + status + (1 | X) + (1 | 
#     popu) + (1 | gen)
#              Df   dAIC
# &lt;none&gt;           0.000
# rack          1 55.083
# status        2  1.612
# nutrient:amd  1  1.444
```
]

---
# S√©lection du mod√®le
.small[

```r
dd_LRT &lt;- drop1(mpl1,test="Chisq")
(dd_AIC &lt;- dfun(drop1(mpl1)))
# Single term deletions
# 
# Model:
# total.fruits ~ nutrient * amd + rack + status + (1 | X) + (1 | 
#     popu) + (1 | gen)
#              Df   dAIC
# &lt;none&gt;           0.000
# rack          1 55.083
# status        2  1.612
# nutrient:amd  1  1.444
```
]

- Fort effet de **rack** (dAIC = 55.08 si on enl√®ve cette variable)
- Effets de **status** et de l'**interaction** sont faibles (dAIC &lt; 2)
- Commen√ßons par **enlever l'interaction non significative** afin de tester les effets principaux de nutriments et d'herbivorie

---
# S√©lection du mod√®le

&lt;br&gt;

.pull-left2[

```r
mpl2 &lt;- update(mpl1, . ~ . - and:nutrient)
# Utiliser AIC
mpl3 &lt;- update(mpl2, . ~ . - rack) # pas de rack ou interaction
mpl4 &lt;- update(mpl2, . ~ . - status) # pas de status ou interaction
mpl5 &lt;- update(mpl2, . ~ . - nutrient) # pas de nutrient ou interaction
mpl6 &lt;- update(mpl2, . ~ . - amd) # pas d'herbivorie ou interaction
# bbmle::ICtab(mpl2, mpl3, mpl4, mpl5, mpl6,
#              type = c("AICc"))

# Ou utiliser drop1
dd_LRT2 &lt;- drop1(mpl2,test="Chisq")
dd_AIC2 &lt;- dfun(drop1(mpl2))
```
]
.pull-right2[

```r
library(bbmle)
ICtab(mpl2, mpl3 ,mpl4,
      mpl5, mpl6,
      type = c("AICc"))
#      dAICc df
# mpl2  0.0  10
# mpl5  0.0  10
# mpl4  1.5  8 
# mpl6 10.6  9 
# mpl3 55.0  9
```
]


---
# S√©lection du mod√®le
&lt;br&gt;

- Fort effets de **nutriments** et d'**herbivorie** (grand changement d'AIC de `\(135.6\)` (`mpl5`) et `\(10.2\)` (`mpl6`) si l'un ou l'autre sont supprim√©s, respectivement).
- Notre mod√®le final inclut l'effet fixe de nutriments, d'herbivorie, la variable nuisance de rack, l'effet al√©atoire au niveau de l'observation `(1|X)` et la variation de fruits par populations et g√©notypes.


---
# Pr√™t pour un d√©fi? ![:cube]()

En utilisant l'ensemble de donn√©es `inverts` (temps de d√©veloppement larvaire (`PLD`) de 74 esp√®ces d'invert√©br√©s et vert√©br√©s marins √©lev√©s √† diff√©rentes temp√©ratures et temps), r√©pondez aux questions suivantes:

- Quel est l'effet du type d'alimentation et du climat (**effets fixes**) sur `PLD`?
- Est-ce que cette relation varie selon les taxons (**effets al√©atoires**)?
- Quelle est la **meilleure famille de distributions** pour ces donn√©es?
- Finalement, une fois que vous avez d√©termin√© la meilleure famille de distribution, re-√©valuez vos effets fixes et al√©atoires.


---
# Solution


```r
# inverts &lt;- read.csv('data/inverts.csv', header = TRUE)
# head(inverts)
# table(inverts$temp, inverts$feeding.type)
#
# mod.glm &lt;- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)
# summary(mod.glm)
# drop1(mod.glm, test = "Chisq")
#
# boxplot(PLD ~ temp,  data = inverts)
# boxplot(PLD ~ feeding.type ,  data = inverts)
#
# boxplot(predict(mod.glm, type = "response")~inverts$temp)
#
# plot()
#
# modglm &lt;- glm(PLD ~ temp + feeding.type, family = poisson(), data = inverts)


#
# r2 &lt;- ranef(mpl1, condVar = TRUE)
# d2 &lt;- dotplot(r2, par.settings = pp)
#
#
# plot(aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2], pch = 19)
# abline(a=0, b = 1, lty =2)
#
# mod.glmer &lt;- glmer.nb(PLD ~ temp + feeding.type + (1|taxon), data = inverts)
# mod.glm &lt;- glm.nb(PLD ~ temp + feeding.type, family = poisson(), data = inverts)

```

plot(aggregate(PLD ~ taxon, FUN=var, data = inverts)[,2],aggregate(PLD ~ taxon, FUN=mean, data = inverts)[,2])
abline(a=0, b =1, lty =2 )


---
# Ressources additionnelles sur les GLMMs

**Livres** :

- B. Bolker (2009) Ecological Models and Data in R. Princeton University Press.
- A. Zuur et al. (2009) Mixed Effects Models and Extensions in Ecology with R. Springer.

**Articles** :

- [Harrison et al. (2018), PeerJ, DOI 10.7717/peerj.4794
](http://dx.doi.org/10.7717/peerj.4794)

**Sites internet** :

- GLMM for ecologists (http://glmm.wikidot.com) .small[.comment[A great website on GLMM with a Q&amp;A section!]]

---
class: inverse, center, bottom

# Merci pour votre participation √† cet atelier!

&lt;hr&gt;

![:scale 50%](images/qcbs_logo.png)

&lt;br&gt;
&lt;br&gt;
    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script src="qcbsR-macros.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"highlightStyle": "github"
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
(function() {
  "use strict"
  /* Replace <script> tags in slides area to make them executable
   *
   * Runs after post-processing of markdown source into slides and replaces only
   * <script>s on the last slide of continued slides using the .has-continuation
   * class added by xaringan. Finally, any <script>s in the slides area that
   * aren't executed are commented out.
   */
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container:not(.has-continuation) script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
  var scriptsNotExecuted = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container.has-continuation script'
  );
  if (!scriptsNotExecuted.length) return;
  for (var i = 0; i < scriptsNotExecuted.length; i++) {
    var comment = document.createComment(scriptsNotExecuted[i].outerHTML)
    scriptsNotExecuted[i].parentElement.replaceChild(comment, scriptsNotExecuted[i])
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
